name: Deploy to AWS ECS with Auto-Destroy

on:
  pull_request:
    types: [closed]
    branches: [main]

  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "main"
        type: string
      confirm:
        description: "Type 'yes' to confirm deployment"
        required: true
        type: string
        default: "yes"

env:
  AWS_REGION: "us-east-1"
  ECR_REPOSITORY: "auth-service"
  ECS_CLUSTER: "auth-cluster"
  CONTAINER_NAME: "auth-container"
  RDS_INSTANCE: "auth-db-${{ github.run_id }}"
  ECS_SERVICE: "auth-service-${{ github.run_id }}"

jobs:
  # ============================================
  # JOB 1: Verificar se foi MERGE (nÃ£o apenas closed)
  # ============================================
  check-merge:
    name: ğŸ” Check Merge Status
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      pr_title: ${{ github.event.pull_request.title }}
      merged_by: ${{ github.event.pull_request.merged_by.login }}

    steps:
      - name: ğŸ“‹ Verify if PR was merged
        id: check
        run: |
          echo "PR Action: ${{ github.event.action }}"
          echo "PR Merged: ${{ github.event.pull_request.merged }}"
          echo "PR Title: ${{ github.event.pull_request.title }}"

          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "âœ… PR WAS MERGED INTO MAIN - DEPLOYMENT WILL RUN"
            echo "Merged by: ${{ github.event.pull_request.merged_by.login }}"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ PR was CLOSED without merge - SKIPPING DEPLOY"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # ============================================
  # JOB 2: Build Docker Image
  # ============================================
  build-docker:
    name: ğŸ³ Build & Push Docker Image
    needs: check-merge
    if: |
      (github.event_name == 'pull_request' && needs.check-merge.outputs.should_deploy == 'true') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.confirm == 'yes')
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      ecr_registry: ${{ steps.build.outputs.ecr_registry }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: ğŸ‰ Deployment trigger info
        run: |
          echo "========================================"
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ğŸ‰ AUTOMATED DEPLOYMENT AFTER PR MERGE"
            echo "PR: ${{ needs.check-merge.outputs.pr_title }}"
            echo "Merged by: ${{ needs.check-merge.outputs.merged_by }}"
          else
            echo "ğŸ® MANUAL DEPLOYMENT"
            echo "Triggered by: ${{ github.actor }}"
          fi
          echo "Run ID: ${{ github.run_id }}"
          echo "========================================"

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ³ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Create ECR Repository if not exists
        run: |
          echo "ğŸ—ï¸ Checking if ECR repository exists..."

          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} > /dev/null 2>&1; then
            echo "âœ… Repository already exists"
          else
            echo "ğŸ“¦ Creating ECR repository..."
            aws ecr create-repository \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --image-tag-mutability MUTABLE \
              --tags Key=Project,Value=Academic
            echo "âœ… Repository created successfully"
          fi

      - name: ğŸ—ï¸ Build Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: deploy-${{ github.run_id }}
        run: |
          echo "ğŸ”¨ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .

          echo "ğŸ“¤ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          echo "âœ… Image pushed successfully!"
          echo "Registry: $ECR_REGISTRY"
          echo "Repository: $ECR_REPOSITORY"
          echo "Tag: $IMAGE_TAG"

          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 3: Deploy na AWS
  # ============================================
  deploy-aws:
    name: ğŸš€ Deploy to AWS ECS
    needs: build-docker
    if: success()
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      public_ip: ${{ steps.get-ip.outputs.PUBLIC_IP }}
      service_url: ${{ steps.get-url.outputs.SERVICE_URL }}

    steps:
      - name: ğŸ“‹ Starting AWS deployment
        run: |
          echo "========================================"
          echo "ğŸš€ DEPLOYING TO AWS ECS FARGATE"
          echo "========================================"
          echo "Run ID: ${{ github.run_id }}"
          echo "Image: ${{ needs.build-docker.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-docker.outputs.image_tag }}"
          echo "========================================"

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ—„ï¸ Create PostgreSQL Database
        id: create-db
        run: |
          echo "ğŸ—„ï¸ Creating RDS PostgreSQL instance..."

          DB_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 16)
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV

          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --allocated-storage 20 \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --backup-retention-period 0 \
            --publicly-accessible \
            --no-multi-az \
            --no-auto-minor-version-upgrade \
            --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true Key=RunId,Value=${{ github.run_id }}

          echo "âœ… RDS instance creation started: ${{ env.RDS_INSTANCE }}"

      - name: â³ Wait for database to be available
        run: |
          echo "â³ Waiting for database to be ready (max 10 minutes)..."

          for i in {1..30}; do
            STATUS=$(aws rds describe-db-instances \
              --db-instance-identifier ${{ env.RDS_INSTANCE }} \
              --query "DBInstances[0].DBInstanceStatus" \
              --output text 2>/dev/null || echo "creating")
            
            echo "Attempt $i/30 - Status: $STATUS"
            
            if [ "$STATUS" = "available" ]; then
              echo "âœ… Database is ready!"
              break
            fi
            
            if [ "$i" -eq 30 ]; then
              echo "âš ï¸ Database not ready in time, continuing anyway..."
            fi
            
            sleep 20
          done

      - name: ğŸ“ Get database endpoint
        id: db-endpoint
        run: |
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text 2>/dev/null || echo "not-ready")

          echo "RDS_ENDPOINT=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "ğŸ“Œ Database endpoint: $ENDPOINT"

      - name: ğŸ³ Create ECS Cluster
        run: |
          echo "ğŸ³ Creating ECS cluster..."

          aws ecs create-cluster \
            --cluster-name ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}

          echo "âœ… ECS cluster created: ${{ env.ECS_CLUSTER }}-${{ github.run_id }}"

      - name: ğŸ› ï¸ Create ECS Task Execution Role
        id: create-role
        run: |
          echo "ğŸ› ï¸ Creating/verifying ECS task execution role..."

          ROLE_NAME="ecsTaskExecutionRole-${{ github.run_id }}"

          if aws iam get-role --role-name $ROLE_NAME 2>/dev/null; then
            echo "âœ… Role already exists"
          else
            echo "ğŸ“ Creating new role..."
            
            # Usar echo para evitar problemas com here-doc
            echo '{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ecs-tasks.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}' > trust-policy.json
            
            aws iam create-role \
              --role-name $ROLE_NAME \
              --assume-role-policy-document file://trust-policy.json \
              --description "ECS Task Execution Role for Auto-Destroy demo" \
              --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true Key=RunId,Value=${{ github.run_id }}
            
            aws iam attach-role-policy \
              --role-name $ROLE_NAME \
              --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
            
            echo "âœ… Role created: $ROLE_NAME"
          fi

          ROLE_ARN=$(aws iam get-role --role-name $ROLE_NAME --query 'Role.Arn' --output text)
          echo "ROLE_ARN=$ROLE_ARN" >> $GITHUB_OUTPUT
          echo "Role ARN: $ROLE_ARN"

      - name: ğŸ“„ Create Task Definition
        id: create-task
        env:
          ECR_REGISTRY: ${{ needs.build-docker.outputs.ecr_registry }}
          IMAGE_TAG: ${{ needs.build-docker.outputs.image_tag }}
          RDS_ENDPOINT: ${{ steps.db-endpoint.outputs.RDS_ENDPOINT }}
        run: |
          echo "ğŸ“„ Creating task definition..."

          cat > task-definition.json << 'TASKDEFEOF'
{
  "family": "auth-task-${{ github.run_id }}",
  "networkMode": "awsvpc",
  "executionRoleArn": "${{ steps.create-role.outputs.ROLE_ARN }}",
  "containerDefinitions": [
    {
      "name": "${{ env.CONTAINER_NAME }}",
      "image": "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG",
      "portMappings": [
        {
          "containerPort": 1337,
          "hostPort": 1337,
          "protocol": "tcp"
        }
      ],
      "essential": true,
      "environment": [
        {
          "name": "DATABASE_URL",
          "value": "postgresql://postgres:${{ env.DB_PASSWORD }}@$RDS_ENDPOINT:5432/postgres?schema=public"
        },
        {
          "name": "PORT",
          "value": "1337"
        },
        {
          "name": "HOST",
          "value": "0.0.0.0"
        },
        {
          "name": "NODE_ENV",
          "value": "production"
        },
        {
          "name": "JWT_SECRET",
          "value": "${{ secrets.JWT_SECRET || 'academic-jwt-secret-key-123456' }}"
        },
        {
          "name": "ADMIN_SECRET_KEY",
          "value": "${{ secrets.ADMIN_SECRET_KEY || 'academic-admin-secret-key-123456' }}"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/auth-service",
          "awslogs-region": "${{ env.AWS_REGION }}",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ],
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "tags": [
    {"key": "Project", "value": "Academic"},
    {"key": "AutoDestroy", "value": "true"},
    {"key": "RunId", "value": "${{ github.run_id }}"}
  ]
}
TASKDEFEOF

          echo "Task definition content (password hidden):"
          sed 's/postgres:[^@]*@/postgres:******@/g' task-definition.json

          TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "TASK_ARN=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "âœ… Task definition registered: $TASK_ARN"

      - name: ğŸ›¡ï¸ Create Security Group
        id: create-sg
        run: |
          echo "ğŸ›¡ï¸ Creating security group..."

          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)

          echo "Using VPC: $VPC_ID"

          SG_ID=$(aws ec2 create-security-group \
            --group-name "auth-sg-${{ github.run_id }}" \
            --description "Auth Service Security Group - Auto Destroy" \
            --vpc-id $VPC_ID \
            --tag-specifications 'ResourceType=security-group,Tags=[{Key=Project,Value=Academic},{Key=AutoDestroy,Value=true},{Key=RunId,Value=${{ github.run_id }}}]' \
            --query 'GroupId' \
            --output text)

          echo "SG_ID=$SG_ID" >> $GITHUB_OUTPUT

          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 1337 \
            --cidr 0.0.0.0/0

          echo "âœ… Security group created: $SG_ID"
          echo "Port 1337 opened to public"

      - name: ğŸš€ Create ECS Service
        run: |
          echo "ğŸš€ Creating ECS service..."

          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)" \
            --query 'Subnets[0:2].SubnetId' \
            --output text)

          SUBNET_1=$(echo $SUBNETS | cut -d' ' -f1)
          SUBNET_2=$(echo $SUBNETS | cut -d' ' -f2)

          echo "Using subnets: $SUBNET_1, $SUBNET_2"

          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.create-task.outputs.TASK_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --platform-version "LATEST" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],assignPublicIp=ENABLED,securityGroups=[${{ steps.create-sg.outputs.SG_ID }}]}" \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}

          echo "âœ… ECS service created: ${{ env.ECS_SERVICE }}"

      - name: â³ Wait for service to start
        run: |
          echo "â³ Waiting for service to start (up to 3 minutes)..."

          for i in {1..18}; do
            RUNNING=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].runningCount' \
              --output text 2>/dev/null || echo "0")
            
            echo "Attempt $i/18 - Running tasks: $RUNNING"
            
            if [ "$RUNNING" = "1" ]; then
              echo "âœ… Service is running!"
              break
            fi
            
            if [ "$i" -eq 18 ]; then
              echo "âš ï¸ Service taking longer than expected, continuing..."
            fi
            
            sleep 10
          done

      - name: ğŸŒ Get Public IP
        id: get-ip
        run: |
          echo "ğŸŒ Getting public IP address..."

          for i in {1..10}; do
            echo "Attempt $i/10 to get public IP..."
            
            TASK_ARN=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --query 'taskArns[0]' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$TASK_ARN" ]; then
              ENI_ID=$(aws ecs describe-tasks \
                --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                --tasks $TASK_ARN \
                --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ENI_ID" ]; then
                PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $ENI_ID \
                  --query 'NetworkInterfaces[0].Association.PublicIp' \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
                  echo "âœ… Public IP found: $PUBLIC_IP"
                  echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT
                  break
                fi
              fi
            fi
            
            if [ "$i" -eq 10 ]; then
              echo "âš ï¸ Could not retrieve public IP, using placeholder"
              echo "PUBLIC_IP=IP_NOT_AVAILABLE" >> $GITHUB_OUTPUT
            fi
            
            sleep 6
          done

      - name: ğŸ”— Create service URL
        id: get-url
        run: |
          if [ "${{ steps.get-ip.outputs.PUBLIC_IP }}" != "IP_NOT_AVAILABLE" ] && [ -n "${{ steps.get-ip.outputs.PUBLIC_IP }}" ]; then
            SERVICE_URL="http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337"
            echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_OUTPUT
            echo "Service URL: $SERVICE_URL"
          else
            echo "SERVICE_URL=http://IP_NOT_AVAILABLE:1337" >> $GITHUB_OUTPUT
            echo "âš ï¸ Service URL not available yet"
          fi

      - name: â° Schedule Auto-Destruction
        run: |
          echo "â° Scheduling auto-destruction in 5 minutes..."

          # Criar script de destruiÃ§Ã£o com echo para evitar here-doc
          DESTROY_SCRIPT='#!/bin/bash
echo "========================================"
echo "ğŸ§¹ AUTO-DESTRUCTION INITIATED"
echo "========================================"
echo "Time: $(date)"
echo "Run ID: $1"
echo ""

export AWS_ACCESS_KEY_ID="$2"
export AWS_SECRET_ACCESS_KEY="$3"
export AWS_REGION="$4"

echo "â³ Waiting 5 minutes before cleanup..."
sleep 300

echo "ğŸ”§ Starting resource cleanup..."
echo ""

echo "Step 1: Stopping ECS service..."
aws ecs update-service \
  --cluster "$5" \
  --service "$6" \
  --desired-count 0 2>/dev/null || echo "Service already stopped or not found"

sleep 10

echo "Step 2: Deleting ECS service..."
aws ecs delete-service \
  --cluster "$5" \
  --service "$6" \
  --force 2>/dev/null || echo "Service already deleted or not found"

echo "Step 3: Deleting ECS cluster..."
aws ecs delete-cluster --cluster "$5" 2>/dev/null || echo "Cluster already deleted or not found"

echo "Step 4: Deleting RDS instance..."
aws rds delete-db-instance \
  --db-instance-identifier "$7" \
  --skip-final-snapshot \
  --delete-automated-backups 2>/dev/null || echo "RDS already deleted or not found"

echo "Step 5: Deleting security group..."
aws ec2 delete-security-group --group-id "$8" 2>/dev/null || echo "Security group already deleted or not found"

echo ""
echo "âœ…âœ…âœ… CLEANUP COMPLETE âœ…âœ…âœ…"
echo "All resources destroyed at: $(date)"
echo "========================================"'

          echo "$DESTROY_SCRIPT" > /tmp/destroy-resources.sh
          chmod +x /tmp/destroy-resources.sh

          nohup /tmp/destroy-resources.sh \
            "${{ github.run_id }}" \
            "${{ secrets.AWS_ACCESS_KEY_ID }}" \
            "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            "${{ env.AWS_REGION }}" \
            "${{ env.ECS_CLUSTER }}-${{ github.run_id }}" \
            "${{ env.ECS_SERVICE }}" \
            "${{ env.RDS_INSTANCE }}" \
            "${{ steps.create-sg.outputs.SG_ID }}" \
            > /tmp/destroy-log-${{ github.run_id }}.txt 2>&1 &

          echo "âœ… Auto-destruction scheduled successfully"
          echo "ğŸ•’ Will execute at: $(date -d '+5 minutes' '+%H:%M:%S')"
          echo "ğŸ“ Log file: /tmp/destroy-log-${{ github.run_id }}.txt"

      - name: ğŸ“Š Deployment Summary
        run: |
          echo "========================================"
          echo "ğŸ‰ DEPLOYMENT COMPLETED SUCCESSFULLY!"
          echo "========================================"
          echo ""
          echo "âœ… All AWS resources deployed"
          echo ""

          if [ "${{ steps.get-ip.outputs.PUBLIC_IP }}" != "IP_NOT_AVAILABLE" ] && [ -n "${{ steps.get-ip.outputs.PUBLIC_IP }}" ]; then
            echo "ğŸŒ SERVICE IS LIVE AT:"
            echo "   http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337"
            echo ""
            echo "ğŸ“š API Documentation:"
            echo "   http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/api"
            echo ""
            echo "ğŸ”§ Test endpoints:"
            echo "   curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/token"
            echo "   curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/validate"
          else
            echo "âš ï¸ IP address not available yet"
            echo "Service might still be starting..."
            echo "Check ECS console for status"
          fi

          echo ""
          echo "ğŸ•’ AUTO-DESTRUCTION:"
          echo "   Scheduled in 5 minutes"
          echo "   All resources will be automatically deleted"
          echo ""
          echo "ğŸ·ï¸ AWS Resources Created (all tagged AutoDestroy=true):"
          echo "   â€¢ RDS PostgreSQL: ${{ env.RDS_INSTANCE }}"
          echo "   â€¢ ECS Cluster: ${{ env.ECS_CLUSTER }}-${{ github.run_id }}"
          echo "   â€¢ ECS Service: ${{ env.ECS_SERVICE }}"
          echo "   â€¢ Security Group: ${{ steps.create-sg.outputs.SG_ID }}"
          echo ""
          echo "========================================"

      - name: ğŸ§¹ Cleanup on failure
        if: failure()
        run: |
          echo "ğŸ§¹ Cleaning up due to failure..."
          aws ecs delete-service --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} --service ${{ env.ECS_SERVICE }} --force 2>/dev/null || true
          aws rds delete-db-instance --db-instance-identifier ${{ env.RDS_INSTANCE }} --skip-final-snapshot 2>/dev/null || true

  # ============================================
  # JOB 4: Status Final - Todos os Checks
  # ============================================
  all-checks-green:
    name: âœ… All Checks Summary
    needs: [check-merge, build-docker, deploy-aws]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: ğŸ“‹ Generate final report
        run: |
          echo "========================================"
          echo "âœ…âœ…âœ… CI/CD PIPELINE - ALL CHECKS âœ…âœ…âœ…"
          echo "========================================"
          echo ""

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ğŸ“Œ TRIGGER: Automated after PR merge"
            echo "   PR: ${{ needs.check-merge.outputs.pr_title || 'N/A' }}"
            echo "   Merged by: ${{ needs.check-merge.outputs.merged_by || 'N/A' }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ğŸ“Œ TRIGGER: Manual deployment"
            echo "   Executed by: ${{ github.actor }}"
          fi

          echo ""
          echo "ğŸ” JOB STATUS (ALL SHOULD BE GREEN):"
          echo "   1. ğŸ” Check Merge Status: ${{ needs.check-merge.result }}"
          echo "   2. ğŸ³ Build Docker Image: ${{ needs.build-docker.result || 'skipped' }}"
          echo "   3. ğŸš€ Deploy to AWS: ${{ needs.deploy-aws.result || 'skipped' }}"
          echo ""

          if [[ "${{ needs.check-merge.result }}" == "success" ]] && \
             [[ "${{ needs.build-docker.result }}" == "success" ]] && \
             [[ "${{ needs.deploy-aws.result }}" == "success" ]]; then
            echo "ğŸ‰ğŸ‰ğŸ‰ ALL CHECKS ARE GREEN! ğŸ‰ğŸ‰ğŸ‰"
            echo ""
            echo "ğŸ“¹ PERFECT FOR YOUR DEMONSTRATION VIDEO:"
            echo ""
            echo "âœ… 3 GREEN CHECKS SHOWN:"
            echo "   1. âœ… Check Merge Status"
            echo "   2. âœ… Build Docker Image"
            echo "   3. âœ… Deploy to AWS"
            echo "   4. âœ… All Checks Summary (this job)"
            echo ""
            echo "ğŸš€ DEPLOYMENT SUCCESSFUL:"
            if [[ "${{ needs.deploy-aws.outputs.service_url }}" != "http://IP_NOT_AVAILABLE:1337" ]]; then
              echo "   Service URL: ${{ needs.deploy-aws.outputs.service_url }}"
            fi
            echo "   Auto-destruction: Active (5 minutes)"
            echo ""
            echo "ğŸ‘‰ RECORD YOUR SCREEN SHOWING:"
            echo "   - All 4 green checkmarks"
            echo "   - Deployment logs"
            echo "   - Service URL (if available)"
            echo "   - Auto-destruction message"
          elif [[ "${{ needs.check-merge.outputs.should_deploy }}" == "false" ]]; then
            echo "â¸ï¸  PR was closed without merge"
            echo "Deployment was correctly skipped"
            echo ""
            echo "âœ… Pipeline behavior is CORRECT"
          else
            echo "âš ï¸  Some checks did not pass"
            echo "Review the failed jobs above"
          fi

          echo ""
          echo "========================================"
          echo "ğŸ¥ RECORD THIS SCREEN FOR YOUR DEMO!"
          echo "========================================"