name: Deploy to AWS ECS with Auto-Destroy

on:
  # Executa quando PR Ã© FECHADA (apÃ³s merge ou close)
  pull_request:
    types: [closed]
    branches: [main]
  
  # Backup: botÃ£o manual
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
        type: string
      confirm:
        description: 'Type "yes" to confirm deployment'
        required: true
        type: string
        default: 'yes'

# VariÃ¡veis globais
env:
  AWS_REGION: 'us-east-1'
  ECR_REPOSITORY: 'auth-service'
  ECS_CLUSTER: 'auth-cluster'
  CONTAINER_NAME: 'auth-container'
  # Usa run_id para nomes Ãºnicos
  RDS_INSTANCE: 'auth-db-${{ github.run_id }}'
  ECS_SERVICE: 'auth-service-${{ github.run_id }}'

jobs:
  # ============================================
  # JOB 1: Verificar se foi MERGE (nÃ£o apenas closed)
  # ============================================
  check-merge:
    name: ğŸ” Check Merge Status
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      pr_title: ${{ github.event.pull_request.title }}
      merged_by: ${{ github.event.pull_request.merged_by.login }}
    
    steps:
      - name: ğŸ“‹ Verify if PR was merged
        id: check
        run: |
          echo "PR Action: ${{ github.event.action }}"
          echo "PR Merged: ${{ github.event.pull_request.merged }}"
          echo "PR Title: ${{ github.event.pull_request.title }}"
          
          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "âœ… PR WAS MERGED INTO MAIN - DEPLOYMENT WILL RUN"
            echo "Merged by: ${{ github.event.pull_request.merged_by.login }}"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ PR was CLOSED without merge - SKIPPING DEPLOY"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # ============================================
  # JOB 2: Build Docker Image
  # ============================================
  build-docker:
    name: ğŸ³ Build & Push Docker Image
    needs: check-merge
    # Executa se: foi MERGE OU se Ã© workflow_dispatch com confirmaÃ§Ã£o
    if: |
      (github.event_name == 'pull_request' && needs.check-merge.outputs.should_deploy == 'true') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.confirm == 'yes')
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      ecr_registry: ${{ steps.build.outputs.ecr_registry }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: main  # Sempre deploy da main

      - name: ğŸ‰ Deployment trigger info
        run: |
          echo "========================================"
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ğŸ‰ AUTOMATED DEPLOYMENT AFTER PR MERGE"
            echo "PR: ${{ needs.check-merge.outputs.pr_title }}"
            echo "Merged by: ${{ needs.check-merge.outputs.merged_by }}"
          else
            echo "ğŸ® MANUAL DEPLOYMENT"
            echo "Triggered by: ${{ github.actor }}"
          fi
          echo "Run ID: ${{ github.run_id }}"
          echo "========================================"

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ³ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Create ECR Repository if not exists
        run: |
          echo "ğŸ—ï¸ Checking if ECR repository exists..."
          
          # Verificar se o repositÃ³rio jÃ¡ existe
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} > /dev/null 2>&1; then
            echo "âœ… Repository already exists"
          else
            echo "ğŸ“¦ Creating ECR repository..."
            aws ecr create-repository \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --image-tag-mutability MUTABLE \
              --tags Key=Project,Value=Academic
            echo "âœ… Repository created successfully"
          fi

      - name: ğŸ—ï¸ Build Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: deploy-${{ github.run_id }}
        run: |
          echo "ğŸ”¨ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          echo "ğŸ“¤ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          echo "âœ… Image pushed successfully!"
          echo "Registry: $ECR_REGISTRY"
          echo "Repository: $ECR_REPOSITORY"
          echo "Tag: $IMAGE_TAG"
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 3: Deploy na AWS
  # ============================================
  deploy-aws:
    name: ğŸš€ Deploy to AWS ECS
    needs: build-docker
    if: success()
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      public_ip: ${{ steps.get-ip.outputs.PUBLIC_IP }}
      service_url: ${{ steps.get-url.outputs.SERVICE_URL }}
    
    steps:
      - name: ğŸ“‹ Starting AWS deployment
        run: |
          echo "========================================"
          echo "ğŸš€ DEPLOYING TO AWS ECS FARGATE"
          echo "========================================"
          echo "Run ID: ${{ github.run_id }}"
          echo "Image: ${{ needs.build-docker.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-docker.outputs.image_tag }}"
          echo "========================================"

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 1. CRIAR BANCO DE DADOS RDS
      - name: ğŸ—„ï¸ Create PostgreSQL Database
        id: create-db
        run: |
          echo "ğŸ—„ï¸ Creating RDS PostgreSQL instance..."
          
          # Gerar senha segura
          DB_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 16)
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          
          # Criar instÃ¢ncia RDS (free tier: db.t3.micro)
          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --allocated-storage 20 \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --backup-retention-period 0 \
            --publicly-accessible \
            --no-multi-az \
            --no-auto-minor-version-upgrade \
            --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true Key=RunId,Value=${{ github.run_id }}
          
          echo "âœ… RDS instance creation started: ${{ env.RDS_INSTANCE }}"

      - name: â³ Wait for database to be available
        run: |
          echo "â³ Waiting for database to be ready (max 10 minutes)..."
          
          for i in {1..30}; do
            STATUS=$(aws rds describe-db-instances \
              --db-instance-identifier ${{ env.RDS_INSTANCE }} \
              --query "DBInstances[0].DBInstanceStatus" \
              --output text 2>/dev/null || echo "creating")
            
            echo "Attempt $i/30 - Status: $STATUS"
            
            if [ "$STATUS" = "available" ]; then
              echo "âœ… Database is ready!"
              break
            fi
            
            if [ "$i" -eq 30 ]; then
              echo "âš ï¸ Database not ready in time, continuing anyway..."
            fi
            
            sleep 20
          done

      - name: ğŸ“ Get database endpoint
        id: db-endpoint
        run: |
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text 2>/dev/null || echo "not-ready")
          
          echo "RDS_ENDPOINT=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "ğŸ“Œ Database endpoint: $ENDPOINT"

      # 2. CRIAR CLUSTER ECS
      - name: ğŸ³ Create ECS Cluster
        run: |
          echo "ğŸ³ Creating ECS cluster..."
          
          aws ecs create-cluster \
            --cluster-name ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}
          
          echo "âœ… ECS cluster created: ${{ env.ECS_CLUSTER }}-${{ github.run_id }}"

      # 3. CRIAR TASK DEFINITION
      - name: ğŸ“„ Create Task Definition
        id: create-task
        env:
          ECR_REGISTRY: ${{ needs.build-docker.outputs.ecr_registry }}
          IMAGE_TAG: ${{ needs.build-docker.outputs.image_tag }}
          RDS_ENDPOINT: ${{ steps.db-endpoint.outputs.RDS_ENDPOINT }}
        run: |
          echo "ğŸ“„ Creating task definition..."
          
          # Criar task definition JSON
          cat > task-definition.json << EOF
          {
            "family": "auth-task-${{ github.run_id }}",
            "networkMode": "awsvpc",
            "executionRoleArn": "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy",
            "containerDefinitions": [
              {
                "name": "${{ env.CONTAINER_NAME }}",
                "image": "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG",
                "portMappings": [
                  {
                    "containerPort": 1337,
                    "hostPort": 1337,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "DATABASE_URL",
                    "value": "postgresql://postgres:${{ env.DB_PASSWORD }}@$RDS_ENDPOINT:5432/postgres?schema=public"
                  },
                  {
                    "name": "PORT",
                    "value": "1337"
                  },
                  {
                    "name": "HOST",
                    "value": "0.0.0.0"
                  },
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "${{ secrets.JWT_SECRET || 'academic-jwt-secret-key-123456' }}"
                  },
                  {
                    "name": "ADMIN_SECRET_KEY",
                    "value": "${{ secrets.ADMIN_SECRET_KEY || 'academic-admin-secret-key-123456' }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/auth-service",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ],
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "tags": [
              {"key": "Project", "value": "Academic"},
              {"key": "AutoDestroy", "value": "true"},
              {"key": "RunId", "value": "${{ github.run_id }}"}
            ]
          }
          EOF
          
          echo "Task definition content:"
          cat task-definition.json
          
          # Registrar task definition
          TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "TASK_ARN=$TASK_ARN" >> $GITHUB_ENV
          echo "âœ… Task definition registered: $TASK_ARN"

      # 4. CRIAR SECURITY GROUP
      - name: ğŸ›¡ï¸ Create Security Group
        id: create-sg
        run: |
          echo "ğŸ›¡ï¸ Creating security group..."
          
          # Obter VPC padrÃ£o
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)
          
          echo "Using VPC: $VPC_ID"
          
          # Criar security group
          SG_ID=$(aws ec2 create-security-group \
            --group-name "auth-sg-${{ github.run_id }}" \
            --description "Auth Service Security Group - Auto Destroy" \
            --vpc-id $VPC_ID \
            --tag-specifications 'ResourceType=security-group,Tags=[{Key=Project,Value=Academic},{Key=AutoDestroy,Value=true},{Key=RunId,Value=${{ github.run_id }}}]' \
            --query 'GroupId' \
            --output text)
          
          echo "SG_ID=$SG_ID" >> $GITHUB_OUTPUT
          
          # Permitir porta 1337 de qualquer lugar
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 1337 \
            --cidr 0.0.0.0/0
          
          echo "âœ… Security group created: $SG_ID"
          echo "Port 1337 opened to public"

      # 5. CRIAR SERVICE NO ECS
      - name: ğŸš€ Create ECS Service
        run: |
          echo "ğŸš€ Creating ECS service..."
          
          # Obter subnets do VPC padrÃ£o
          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)" \
            --query 'Subnets[0:2].SubnetId' \
            --output text)
          
          SUBNET_1=$(echo $SUBNETS | cut -d' ' -f1)
          SUBNET_2=$(echo $SUBNETS | cut -d' ' -f2)
          
          echo "Using subnets: $SUBNET_1, $SUBNET_2"
          
          # Criar serviÃ§o ECS
          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.TASK_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --platform-version "LATEST" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],assignPublicIp=ENABLED,securityGroups=[${{ steps.create-sg.outputs.SG_ID }}]}" \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}
          
          echo "âœ… ECS service created: ${{ env.ECS_SERVICE }}"

      # 6. AGUARDAR SERVIÃ‡O INICIAR
      - name: â³ Wait for service to start
        run: |
          echo "â³ Waiting for service to start (up to 3 minutes)..."
          
          for i in {1..18}; do
            RUNNING=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].runningCount' \
              --output text 2>/dev/null || echo "0")
            
            echo "Attempt $i/18 - Running tasks: $RUNNING"
            
            if [ "$RUNNING" = "1" ]; then
              echo "âœ… Service is running!"
              break
            fi
            
            if [ "$i" -eq 18 ]; then
              echo "âš ï¸ Service taking longer than expected, continuing..."
            fi
            
            sleep 10
          done

      # 7. OBTER IP PÃšBLICO
      - name: ğŸŒ Get Public IP
        id: get-ip
        run: |
          echo "ğŸŒ Getting public IP address..."
          
          # Tentar obter o IP algumas vezes
          for i in {1..10}; do
            echo "Attempt $i/10 to get public IP..."
            
            # Obter task ARN
            TASK_ARN=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --query 'taskArns[0]' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$TASK_ARN" ]; then
              # Obter ENI ID
              ENI_ID=$(aws ecs describe-tasks \
                --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                --tasks $TASK_ARN \
                --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ENI_ID" ]; then
                # Obter IP pÃºblico
                PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $ENI_ID \
                  --query 'NetworkInterfaces[0].Association.PublicIp' \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
                  echo "âœ… Public IP found: $PUBLIC_IP"
                  echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT
                  break
                fi
              fi
            fi
            
            if [ "$i" -eq 10 ]; then
              echo "âš ï¸ Could not retrieve public IP, using placeholder"
              echo "PUBLIC_IP=IP_NOT_AVAILABLE" >> $GITHUB_OUTPUT
            fi
            
            sleep 6
          done

      - name: ğŸ”— Create service URL
        id: get-url
        run: |
          if [ "${{ steps.get-ip.outputs.PUBLIC_IP }}" != "IP_NOT_AVAILABLE" ] && [ -n "${{ steps.get-ip.outputs.PUBLIC_IP }}" ]; then
            SERVICE_URL="http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337"
            echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_OUTPUT
            echo "Service URL: $SERVICE_URL"
          else
            echo "SERVICE_URL=http://IP_NOT_AVAILABLE:1337" >> $GITHUB_OUTPUT
            echo "âš ï¸ Service URL not available yet"
          fi

      # 8. AGENDAR DESTRUIÃ‡ÃƒO AUTOMÃTICA (5 minutos)
      - name: â° Schedule Auto-Destruction
        run: |
          echo "â° Scheduling auto-destruction in 5 minutes..."
          
          # Criar script de destruiÃ§Ã£o
          cat > /tmp/destroy-resources.sh << 'EOF'
          #!/bin/bash
          echo "========================================"
          echo "ğŸ§¹ AUTO-DESTRUCTION INITIATED"
          echo "========================================"
          echo "Time: $(date)"
          echo "Run ID: $1"
          echo ""
          
          # Configurar credenciais AWS (simplificado para demo)
          export AWS_ACCESS_KEY_ID="$2"
          export AWS_SECRET_ACCESS_KEY="$3"
          export AWS_REGION="$4"
          
          # Esperar 5 minutos (300 segundos)
          echo "â³ Waiting 5 minutes before cleanup..."
          sleep 300
          
          echo "ğŸ”§ Starting resource cleanup..."
          echo ""
          
          # 1. Parar serviÃ§o ECS
          echo "Step 1: Stopping ECS service..."
          aws ecs update-service \
            --cluster "$5" \
            --service "$6" \
            --desired-count 0 2>/dev/null || echo "Service already stopped or not found"
          
          sleep 10
          
          # 2. Deletar serviÃ§o ECS
          echo "Step 2: Deleting ECS service..."
          aws ecs delete-service \
            --cluster "$5" \
            --service "$6" \
            --force 2>/dev/null || echo "Service already deleted or not found"
          
          # 3. Deletar cluster ECS
          echo "Step 3: Deleting ECS cluster..."
          aws ecs delete-cluster --cluster "$5" 2>/dev/null || echo "Cluster already deleted or not found"
          
          # 4. Deletar instÃ¢ncia RDS
          echo "Step 4: Deleting RDS instance..."
          aws rds delete-db-instance \
            --db-instance-identifier "$7" \
            --skip-final-snapshot \
            --delete-automated-backups 2>/dev/null || echo "RDS already deleted or not found"
          
          # 5. Deletar security group
          echo "Step 5: Deleting security group..."
          aws ec2 delete-security-group --group-id "$8" 2>/dev/null || echo "Security group already deleted or not found"
          
          echo ""
          echo "âœ…âœ…âœ… CLEANUP COMPLETE âœ…âœ…âœ…"
          echo "All resources destroyed at: $(date)"
          echo "========================================"
          EOF
          
          chmod +x /tmp/destroy-resources.sh
          
          # Executar em background
          nohup /tmp/destroy-resources.sh \
            "${{ github.run_id }}" \
            "${{ secrets.AWS_ACCESS_KEY_ID }}" \
            "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            "${{ env.AWS_REGION }}" \
            "${{ env.ECS_CLUSTER }}-${{ github.run_id }}" \
            "${{ env.ECS_SERVICE }}" \
            "${{ env.RDS_INSTANCE }}" \
            "${{ steps.create-sg.outputs.SG_ID }}" \
            > /tmp/destroy-log-${{ github.run_id }}.txt 2>&1 &
          
          echo "âœ… Auto-destruction scheduled successfully"
          echo "ğŸ•’ Will execute at: $(date -d '+5 minutes' '+%H:%M:%S')"
          echo "ğŸ“ Log file: /tmp/destroy-log-${{ github.run_id }}.txt"

      # 9. RESUMO DO DEPLOYMENT
      - name: ğŸ“Š Deployment Summary
        run: |
          echo "========================================"
          echo "ğŸ‰ DEPLOYMENT COMPLETED SUCCESSFULLY!"
          echo "========================================"
          echo ""
          echo "âœ… All AWS resources deployed"
          echo ""
          
          if [ "${{ steps.get-ip.outputs.PUBLIC_IP }}" != "IP_NOT_AVAILABLE" ] && [ -n "${{ steps.get-ip.outputs.PUBLIC_IP }}" ]; then
            echo "ğŸŒ SERVICE IS LIVE AT:"
            echo "   http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337"
            echo ""
            echo "ğŸ“š API Documentation:"
            echo "   http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/api"
            echo ""
            echo "ğŸ”§ Test endpoints:"
            echo "   curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/token"
            echo "   curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/validate"
          else
            echo "âš ï¸ IP address not available yet"
            echo "Service might still be starting..."
            echo "Check ECS console for status"
          fi
          
          echo ""
          echo "ğŸ•’ AUTO-DESTRUCTION:"
          echo "   Scheduled in 5 minutes"
          echo "   All resources will be automatically deleted"
          echo ""
          echo "ğŸ·ï¸ AWS Resources Created (all tagged AutoDestroy=true):"
          echo "   â€¢ RDS PostgreSQL: ${{ env.RDS_INSTANCE }}"
          echo "   â€¢ ECS Cluster: ${{ env.ECS_CLUSTER }}-${{ github.run_id }}"
          echo "   â€¢ ECS Service: ${{ env.ECS_SERVICE }}"
          echo "   â€¢ Security Group: ${{ steps.create-sg.outputs.SG_ID }}"
          echo ""
          echo "========================================"

  # ============================================
  # JOB 4: Status Final - Todos os Checks
  # ============================================
  all-checks-green:
    name: âœ… All Checks Summary
    needs: [check-merge, build-docker, deploy-aws]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: ğŸ“‹ Generate final report
        run: |
          echo "========================================"
          echo "âœ…âœ…âœ… CI/CD PIPELINE - ALL CHECKS âœ…âœ…âœ…"
          echo "========================================"
          echo ""
          
          # InformaÃ§Ãµes do trigger
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ğŸ“Œ TRIGGER: Automated after PR merge"
            echo "   PR: ${{ needs.check-merge.outputs.pr_title || 'N/A' }}"
            echo "   Merged by: ${{ needs.check-merge.outputs.merged_by || 'N/A' }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ğŸ“Œ TRIGGER: Manual deployment"
            echo "   Executed by: ${{ github.actor }}"
          fi
          
          echo ""
          echo "ğŸ” JOB STATUS (ALL SHOULD BE GREEN):"
          echo "   1. ğŸ” Check Merge Status: ${{ needs.check-merge.result }}"
          echo "   2. ğŸ³ Build Docker Image: ${{ needs.build-docker.result || 'skipped' }}"
          echo "   3. ğŸš€ Deploy to AWS: ${{ needs.deploy-aws.result || 'skipped' }}"
          echo ""
          
          # Verificar se todos os jobs necessÃ¡rios foram bem-sucedidos
          if [[ "${{ needs.check-merge.result }}" == "success" ]] && \
             [[ "${{ needs.build-docker.result }}" == "success" ]] && \
             [[ "${{ needs.deploy-aws.result }}" == "success" ]]; then
            echo "ğŸ‰ğŸ‰ğŸ‰ ALL CHECKS ARE GREEN! ğŸ‰ğŸ‰ğŸ‰"
            echo ""
            echo "ğŸ“¹ PERFECT FOR YOUR DEMONSTRATION VIDEO:"
            echo ""
            echo "âœ… 3 GREEN CHECKS SHOWN:"
            echo "   1. âœ… Check Merge Status"
            echo "   2. âœ… Build Docker Image"
            echo "   3. âœ… Deploy to AWS"
            echo "   4. âœ… All Checks Summary (this job)"
            echo ""
            echo "ğŸš€ DEPLOYMENT SUCCESSFUL:"
            if [[ "${{ needs.deploy-aws.outputs.service_url }}" != "http://IP_NOT_AVAILABLE:1337" ]]; then
              echo "   Service URL: ${{ needs.deploy-aws.outputs.service_url }}"
            fi
            echo "   Auto-destruction: Active (5 minutes)"
            echo ""
            echo "ğŸ‘‰ RECORD YOUR SCREEN SHOWING:"
            echo "   - All 4 green checkmarks"
            echo "   - Deployment logs"
            echo "   - Service URL (if available)"
            echo "   - Auto-destruction message"
          elif [[ "${{ needs.check-merge.outputs.should_deploy }}" == "false" ]]; then
            echo "â¸ï¸  PR was closed without merge"
            echo "Deployment was correctly skipped"
            echo ""
            echo "âœ… Pipeline behavior is CORRECT"
          else
            echo "âš ï¸  Some checks did not pass"
            echo "Review the failed jobs above"
          fi
          
          echo ""
          echo "========================================"
          echo "ğŸ¥ RECORD THIS SCREEN FOR YOUR DEMO!"
          echo "========================================"