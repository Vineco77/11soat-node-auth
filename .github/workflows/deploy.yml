name: Deploy to AWS ECS with Auto-Destroy

on:
  # 1. Em PRs para main: s√≥ roda verifica√ß√µes
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  
  # 2. Em pushes para develop: s√≥ roda verifica√ß√µes
  push:
    branches: [develop]
  
  # 3. Bot√£o manual para deploy (VOC√ä VAI USAR ISSO!)
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        default: 'demo'
        type: string
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
        type: string

# Vari√°veis globais
env:
  AWS_REGION: 'us-east-1'  # Free tier friendly
  ECR_REPOSITORY: 'auth-service'
  ECS_CLUSTER: 'auth-cluster'
  ECS_SERVICE: 'auth-service'
  CONTAINER_NAME: 'auth-container'
  # Nomes √∫nicos por execu√ß√£o para evitar conflitos
  RDS_INSTANCE: 'auth-db-${{ github.run_id }}'

jobs:
  # ============================================
  # JOB 1: Verifica√ß√µes (Sempre roda em PRs)
  # ============================================
  verify-pr:
    name: üî¨ Verify PR Quality
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: üì¶ Install dependencies
        run: npm ci
        
      - name: üèóÔ∏è Build application
        run: npm run build
        
      - name: üß™ Run tests with coverage
        run: npm run test:coverage
        
      - name: ‚úÖ Create verification summary
        run: |
          echo "========================================"
          echo "‚úÖ VERIFICATION COMPLETE"
          echo "========================================"
          echo "All checks passed for PR/develop push"
          echo "Ready for manual deployment via workflow_dispatch"
          echo "========================================"

  # ============================================
  # JOB 2: Build da Imagem Docker (S√≥ no deploy manual)
  # ============================================
  build-docker:
    name: üê≥ Build & Push Docker Image
    # S√ì EXECUTA quando voc√™ clicar no bot√£o "Run workflow"
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      ecr_registry: ${{ steps.build.outputs.ecr_registry }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || 'main' }}

      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üê≥ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üèóÔ∏è Build Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: deploy-${{ github.run_id }}
        run: |
          echo "üî® Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          echo "üì§ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          echo "‚úÖ Image pushed successfully!"
          echo "Registry: $ECR_REGISTRY"
          echo "Repository: $ECR_REPOSITORY"
          echo "Tag: $IMAGE_TAG"
          
          # Salvar outputs para o pr√≥ximo job
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 3: Deploy na AWS (S√≥ no deploy manual)
  # ============================================
  deploy-aws:
    name: üöÄ Deploy to AWS ECS
    needs: build-docker
    # S√ì EXECUTA quando voc√™ clicar no bot√£o "Run workflow"
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
      - name: üìã Deployment started
        run: |
          echo "========================================"
          echo "üöÄ STARTING DEPLOYMENT TO AWS"
          echo "========================================"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Branch: ${{ github.event.inputs.branch }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "========================================"

      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 1. CRIAR BANCO DE DADOS RDS
      - name: üóÑÔ∏è Create PostgreSQL Database
        id: create-db
        run: |
          echo "üóÑÔ∏è Creating RDS PostgreSQL instance..."
          
          # Gerar senha segura
          DB_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 16)
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          
          # Criar inst√¢ncia RDS (free tier)
          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --allocated-storage 20 \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --backup-retention-period 0 \
            --publicly-accessible \
            --no-multi-az \
            --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true Key=RunId,Value=${{ github.run_id }}
          
          echo "‚úÖ RDS creation started"
          echo "Instance ID: ${{ env.RDS_INSTANCE }}"

      - name: ‚è≥ Wait for database
        run: |
          echo "‚è≥ Waiting for database to be ready..."
          for i in {1..30}; do
            STATUS=$(aws rds describe-db-instances \
              --db-instance-identifier ${{ env.RDS_INSTANCE }} \
              --query "DBInstances[0].DBInstanceStatus" \
              --output text 2>/dev/null || echo "creating")
            
            echo "Attempt $i/30 - Status: $STATUS"
            
            if [ "$STATUS" = "available" ]; then
              echo "‚úÖ Database is ready!"
              break
            fi
            
            if [ "$i" -eq 30 ]; then
              echo "‚ùå Database not ready in time"
              exit 1
            fi
            
            sleep 10
          done

      - name: üìç Get database endpoint
        id: db-endpoint
        run: |
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text)
          
          echo "RDS_ENDPOINT=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "üìå Database endpoint: $ENDPOINT"

      # 2. CRIAR CLUSTER ECS
      - name: üê≥ Create ECS Cluster
        run: |
          echo "üê≥ Creating ECS cluster..."
          
          aws ecs create-cluster \
            --cluster-name ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}
          
          echo "‚úÖ ECS cluster created"

      # 3. CRIAR TASK DEFINITION
      - name: üìÑ Create Task Definition
        env:
          ECR_REGISTRY: ${{ needs.build-docker.outputs.ecr_registry }}
          IMAGE_TAG: ${{ needs.build-docker.outputs.image_tag }}
          RDS_ENDPOINT: ${{ steps.db-endpoint.outputs.RDS_ENDPOINT }}
        run: |
          echo "üìÑ Creating task definition..."
          
          cat > task-def.json << EOF
          {
            "family": "auth-task-${{ github.run_id }}",
            "networkMode": "awsvpc",
            "executionRoleArn": "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy",
            "containerDefinitions": [
              {
                "name": "${{ env.CONTAINER_NAME }}",
                "image": "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG",
                "portMappings": [
                  {
                    "containerPort": 1337,
                    "hostPort": 1337,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "DATABASE_URL",
                    "value": "postgresql://postgres:${{ env.DB_PASSWORD }}@$RDS_ENDPOINT:5432/postgres?schema=public"
                  },
                  {
                    "name": "PORT",
                    "value": "1337"
                  },
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "${{ secrets.JWT_SECRET || 'academic-jwt-secret-123' }}"
                  },
                  {
                    "name": "ADMIN_SECRET_KEY",
                    "value": "${{ secrets.ADMIN_SECRET_KEY || 'academic-admin-key-123' }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/auth-service",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ],
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "tags": [
              {"key": "Project", "value": "Academic"},
              {"key": "AutoDestroy", "value": "true"}
            ]
          }
          EOF
          
          # Registrar task definition
          TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "TASK_ARN=$TASK_ARN" >> $GITHUB_ENV
          echo "‚úÖ Task definition created: $TASK_ARN"

      # 4. CRIAR SECURITY GROUP
      - name: üõ°Ô∏è Create Security Group
        id: create-sg
        run: |
          echo "üõ°Ô∏è Creating security group..."
          
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)
          
          SG_ID=$(aws ec2 create-security-group \
            --group-name "auth-sg-${{ github.run_id }}" \
            --description "Auth Service - Auto Destroy" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          
          echo "SG_ID=$SG_ID" >> $GITHUB_OUTPUT
          
          # Permitir tr√°fego na porta 1337
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 1337 \
            --cidr 0.0.0.0/0
          
          echo "‚úÖ Security group created: $SG_ID"

      # 5. CRIAR SERVICE NO ECS
      - name: üöÄ Create ECS Service
        run: |
          echo "üöÄ Creating ECS service..."
          
          # Obter subnets
          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)" \
            --query 'Subnets[0:2].SubnetId' \
            --output text)
          
          SUBNET_1=$(echo $SUBNETS | cut -d' ' -f1)
          SUBNET_2=$(echo $SUBNETS | cut -d' ' -f2)
          
          echo "Using subnets: $SUBNET_1, $SUBNET_2"
          
          # Criar servi√ßo
          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --service-name ${{ env.ECS_SERVICE }}-${{ github.run_id }} \
            --task-definition ${{ env.TASK_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --platform-version "LATEST" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],assignPublicIp=ENABLED,securityGroups=[${{ steps.create-sg.outputs.SG_ID }}]}" \
            --tags key=Project,value=Academic key=AutoDestroy,value=true
          
          echo "‚úÖ ECS service created"

      # 6. AGUARDAR SERVI√áO
      - name: ‚è≥ Wait for service
        run: |
          echo "‚è≥ Waiting for service to start..."
          sleep 45
          
          # Verificar status
          RUNNING=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --services ${{ env.ECS_SERVICE }}-${{ github.run_id }} \
            --query 'services[0].runningCount' \
            --output text)
          
          echo "Running tasks: $RUNNING"

      # 7. OBTER IP P√öBLICO
      - name: üåê Get Public IP
        id: get-ip
        run: |
          echo "üåê Getting public IP..."
          
          # Tentar algumas vezes (o servi√ßo pode estar inicializando)
          for i in {1..10}; do
            echo "Attempt $i/10 to get task IP..."
            
            TASK_ARN=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --service-name ${{ env.ECS_SERVICE }}-${{ github.run_id }} \
              --query 'taskArns[0]' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$TASK_ARN" ]; then
              ENI_ID=$(aws ecs describe-tasks \
                --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                --tasks $TASK_ARN \
                --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ENI_ID" ]; then
                PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $ENI_ID \
                  --query 'NetworkInterfaces[0].Association.PublicIp' \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$PUBLIC_IP" ]; then
                  echo "‚úÖ Got IP: $PUBLIC_IP"
                  echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT
                  break
                fi
              fi
            fi
            
            if [ "$i" -eq 10 ]; then
              echo "‚ö†Ô∏è Could not get IP, service might still be starting"
              echo "PUBLIC_IP=unknown" >> $GITHUB_OUTPUT
            fi
            
            sleep 10
          done

      # 8. AGENDAR DESTRUI√á√ÉO
      - name: ‚è∞ Schedule Auto-Destruction
        run: |
          echo "‚è∞ Scheduling auto-destruction in 5 minutes..."
          
          # Criar script de destrui√ß√£o
          cat > /tmp/destroy.sh << 'EOF'
          #!/bin/bash
          echo "========================================"
          echo "üßπ AUTO-DESTROY INITIATED"
          echo "========================================"
          echo "Time: $(date)"
          echo ""
          
          # Esperar 5 minutos
          echo "‚è≥ Waiting 5 minutes before cleanup..."
          sleep 300
          
          echo "üîß Starting cleanup..."
          
          # 1. Parar servi√ßo ECS
          echo "Stopping ECS service..."
          aws ecs update-service \
            --cluster $1 \
            --service $2 \
            --desired-count 0 2>/dev/null || echo "Service already stopped"
          
          sleep 10
          
          # 2. Deletar servi√ßo
          echo "Deleting ECS service..."
          aws ecs delete-service \
            --cluster $1 \
            --service $2 \
            --force 2>/dev/null || echo "Service already deleted"
          
          # 3. Deletar cluster
          echo "Deleting ECS cluster..."
          aws ecs delete-cluster --cluster $1 2>/dev/null || echo "Cluster already deleted"
          
          # 4. Deletar RDS
          echo "Deleting RDS instance..."
          aws rds delete-db-instance \
            --db-instance-identifier $3 \
            --skip-final-snapshot \
            --delete-automated-backups 2>/dev/null || echo "RDS already deleted"
          
          # 5. Deletar security group
          echo "Deleting security group..."
          aws ec2 delete-security-group --group-id $4 2>/dev/null || echo "SG already deleted"
          
          echo ""
          echo "‚úÖ‚úÖ‚úÖ CLEANUP COMPLETE ‚úÖ‚úÖ‚úÖ"
          echo "Finished at: $(date)"
          EOF
          
          chmod +x /tmp/destroy.sh
          
          # Executar em background
          nohup /tmp/destroy.sh \
            "${{ env.ECS_CLUSTER }}-${{ github.run_id }}" \
            "${{ env.ECS_SERVICE }}-${{ github.run_id }}" \
            "${{ env.RDS_INSTANCE }}" \
            "${{ steps.create-sg.outputs.SG_ID }}" \
            > /tmp/destroy-log-${{ github.run_id }}.txt 2>&1 &
          
          echo "‚úÖ Auto-destruction scheduled"
          echo "üïí Will execute at: $(date -d '+5 minutes' '+%H:%M:%S')"

      # 9. RESUMO FINAL
      - name: üìä Deployment Summary
        run: |
          echo "========================================"
          echo "üéâ DEPLOYMENT COMPLETE!"
          echo "========================================"
          echo ""
          echo "‚úÖ All resources deployed successfully"
          echo ""
          
          if [ "${{ steps.get-ip.outputs.PUBLIC_IP }}" != "unknown" ] && [ -n "${{ steps.get-ip.outputs.PUBLIC_IP }}" ]; then
            echo "üåê SERVICE URL:"
            echo "   http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337"
            echo ""
            echo "üìö API Documentation:"
            echo "   http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/api"
            echo ""
            echo "üîß Test endpoints:"
            echo "   curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/token"
            echo "   curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/validate"
          else
            echo "‚ö†Ô∏è IP address not available yet"
            echo "Service might still be starting..."
          fi
          
          echo ""
          echo "üïí AUTO-DESTRUCTION:"
          echo "   Scheduled in 5 minutes"
          echo "   All resources will be automatically deleted"
          echo ""
          echo "üè∑Ô∏è AWS Resources (tagged with AutoDestroy=true):"
          echo "   ‚Ä¢ RDS: ${{ env.RDS_INSTANCE }}"
          echo "   ‚Ä¢ ECS Cluster: ${{ env.ECS_CLUSTER }}-${{ github.run_id }}"
          echo "   ‚Ä¢ ECS Service: ${{ env.ECS_SERVICE }}-${{ github.run_id }}"
          echo "   ‚Ä¢ Security Group: ${{ steps.create-sg.outputs.SG_ID }}"
          echo ""
          echo "========================================"
          echo "üé• RECORD YOUR SCREEN FOR DEMONSTRATION"
          echo "========================================"

  # ============================================
  # JOB 4: Status Final (Sempre roda)
  # ============================================
  final-checks:
    name: ‚úÖ All Checks Summary
    runs-on: ubuntu-latest
    needs: [verify-pr, build-docker, deploy-aws]
    if: always()
    
    steps:
      - name: üìã Generate final report
        run: |
          echo "========================================"
          echo "üìä CI/CD PIPELINE - ALL CHECKS"
          echo "========================================"
          echo ""
          echo "üîç VERIFICATION STATUS:"
          echo "   SonarQube & Tests: ${{ needs.verify-pr.result || 'skipped' }}"
          echo ""
          echo "üê≥ DOCKER BUILD STATUS:"
          echo "   Build & Push: ${{ needs.build-docker.result || 'skipped' }}"
          echo ""
          echo "üöÄ DEPLOYMENT STATUS:"
          echo "   AWS Deploy: ${{ needs.deploy-aws.result || 'skipped' }}"
          echo ""
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ needs.deploy-aws.result }}" == "success" ]]; then
            echo "‚úÖ‚úÖ‚úÖ ALL GREEN CHECKS ACHIEVED! ‚úÖ‚úÖ‚úÖ"
            echo ""
            echo "üìπ RECORD THIS SCREEN FOR YOUR DEMO VIDEO:"
            echo "   1. All 3 jobs show green checkmarks"
            echo "   2. Each job completed successfully"
            echo "   3. Deployment summary shows service URL"
            echo ""
            echo "üëâ NEXT STEPS:"
            echo "   1. Take screenshot of green checks"
            echo "   2. Record video showing pipeline success"
            echo "   3. Test the deployed service"
            echo "   4. Resources auto-destroy in 5 minutes"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "‚úÖ PR CHECKS COMPLETE"
            echo "Ready for merge. Deploy manually after merge."
          fi
          
          echo ""
          echo "========================================"