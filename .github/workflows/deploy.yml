name: Deploy to AWS ECS with Auto-Destroy

on:
  push:
    branches: [main, master]
  workflow_dispatch:  # Permite execu√ß√£o manual

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  ECR_REPOSITORY: ${{ vars.AWS_ECR_REPOSITORY || 'auth-service' }}
  ECS_CLUSTER: ${{ vars.AWS_ECS_CLUSTER || 'auth-cluster' }}
  ECS_SERVICE: ${{ vars.AWS_ECS_SERVICE || 'auth-service' }}
  ECS_TASK_DEFINITION: .github/aws/task-definition.json
  CONTAINER_NAME: auth-container
  RDS_INSTANCE: ${{ vars.AWS_RDS_INSTANCE_ID || 'auth-db-instance' }}

jobs:
  test-and-sonar:
    uses: ./.github/workflows/sonar.yml
    secrets: inherit

  build-and-push:
    needs: test-and-sonar
    if: success()
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üê≥ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üèóÔ∏è Build, tag, and push image to Amazon ECR
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          echo "Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

      - name: üíæ Save image info
        run: |
          echo "Image pushed successfully!"
          echo "Registry: ${{ steps.login-ecr.outputs.registry }}"
          echo "Repository: ${{ env.ECR_REPOSITORY }}"
          echo "Tag: ${{ steps.build.outputs.image_tag }}"

  deploy-infrastructure:
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üóÇÔ∏è Create AWS infrastructure directory
        run: mkdir -p .github/aws

      - name: üìù Create RDS PostgreSQL instance
        id: create-rds
        run: |
          echo "üîÑ Creating RDS PostgreSQL instance..."
          
          # Gerar senha segura para o banco
          DB_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 16)
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          
          # Criar inst√¢ncia RDS (db.t3.micro est√° no free tier)
          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --allocated-storage 20 \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --backup-retention-period 0 \
            --publicly-accessible \
            --no-multi-az \
            --no-auto-minor-version-upgrade \
            --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true
          
          echo "‚úÖ RDS instance creation initiated"
          echo "Instance: ${{ env.RDS_INSTANCE }}"
          echo "Username: postgres"
          echo "Password: [hidden]"

      - name: ‚è≥ Wait for RDS to be available
        run: |
          echo "‚è≥ Waiting for RDS instance to be available (max 10 minutes)..."
          aws rds wait db-instance-available \
            --db-instance-identifier ${{ env.RDS_INSTANCE }}
          echo "‚úÖ RDS instance is now available"

      - name: üì° Get RDS endpoint
        id: rds-endpoint
        run: |
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text)
          echo "RDS_ENDPOINT=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "Database endpoint: $ENDPOINT"

      - name: üê≥ Create ECS cluster
        run: |
          echo "üîÑ Creating ECS cluster..."
          aws ecs create-cluster \
            --cluster-name ${{ env.ECS_CLUSTER }} \
            --tags key=Project,value=Academic key=AutoDestroy,value=true
          echo "‚úÖ ECS cluster created"

      - name: üìÑ Create task definition
        env:
          ECR_REGISTRY: ${{ needs.build-and-push.outputs.ecr_registry }}
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
          RDS_ENDPOINT: ${{ steps.rds-endpoint.outputs.RDS_ENDPOINT }}
        run: |
          echo "üìù Creating task definition..."
          
          # Criar arquivo de task definition
          cat > ${{ env.ECS_TASK_DEFINITION }} << EOF
          {
            "family": "${{ env.ECS_TASK_DEFINITION }}",
            "networkMode": "awsvpc",
            "executionRoleArn": "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy",
            "containerDefinitions": [
              {
                "name": "${{ env.CONTAINER_NAME }}",
                "image": "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG",
                "portMappings": [
                  {
                    "containerPort": 1337,
                    "hostPort": 1337,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "DATABASE_URL",
                    "value": "postgresql://postgres:${{ env.DB_PASSWORD }}@$RDS_ENDPOINT:5432/auth_db"
                  },
                  {
                    "name": "PORT",
                    "value": "1337"
                  },
                  {
                    "name": "HOST",
                    "value": "0.0.0.0"
                  },
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "${{ secrets.JWT_SECRET }}"
                  },
                  {
                    "name": "ADMIN_SECRET_KEY",
                    "value": "${{ secrets.ADMIN_SECRET_KEY }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/${{ env.ECS_CLUSTER }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:1337/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ],
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "tags": [
              {"key": "Project", "value": "Academic"},
              {"key": "AutoDestroy", "value": "true"}
            ]
          }
          EOF
          
          echo "‚úÖ Task definition file created"
          
          # Registrar task definition
          aws ecs register-task-definition \
            --cli-input-json file://${{ env.ECS_TASK_DEFINITION }}
          
          echo "‚úÖ Task definition registered"

      - name: üîê Create security group
        id: security-group
        run: |
          echo "üõ°Ô∏è Creating security group..."
          
          # Criar security group
          SG_ID=$(aws ec2 create-security-group \
            --group-name "auth-service-sg-${{ github.run_id }}" \
            --description "Security group for Auth Service" \
            --vpc-id $(aws ec2 describe-vpcs --query 'Vpcs[0].VpcId' --output text) \
            --query 'GroupId' \
            --output text)
          
          echo "SG_ID=$SG_ID" >> $GITHUB_OUTPUT
          echo "Security Group ID: $SG_ID"
          
          # Adicionar regra para porta 1337
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 1337 \
            --cidr 0.0.0.0/0
          
          # Adicionar regra para SSH (opcional, para debug)
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0
          
          echo "‚úÖ Security group created and configured"

      - name: üöÄ Create ECS service
        env:
          SUBNETS: $(aws ec2 describe-subnets --query 'Subnets[0:2].SubnetId' --output text | tr '\n' ',')
        run: |
          echo "üöÄ Creating ECS service..."
          
          # Obter subnets
          SUBNET_LIST=$(aws ec2 describe-subnets \
            --query 'Subnets[0:2].SubnetId' \
            --output text | tr '\t' ' ')
          
          echo "Using subnets: $SUBNET_LIST"
          
          # Criar servi√ßo ECS
          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --platform-version "LATEST" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_LIST],assignPublicIp=ENABLED,securityGroups=[${{ steps.security-group.outputs.SG_ID }}]}" \
            --tags key=Project,value=Academic key=AutoDestroy,value=true
          
          echo "‚úÖ ECS service created"

      - name: ‚è≥ Wait for service to stabilize
        run: |
          echo "‚è≥ Waiting for service to become stable..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
          echo "‚úÖ Service is now stable"

      - name: üåê Get public IP
        id: get-ip
        run: |
          echo "üîç Getting public IP..."
          
          # Obter ENI do task
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --query 'taskArns[0]' \
            --output text)
          
          ENI_ID=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)
          
          PUBLIC_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $ENI_ID \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text)
          
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Service is running at: http://$PUBLIC_IP:1337"
          
          # Criar output summary
          echo "DEPLOYMENT_SUMMARY={\"url\":\"http://$PUBLIC_IP:1337\",\"timestamp\":\"$(date -Iseconds)\",\"destroy_time\":\"$(date -Iseconds -d '+5 minutes')\"}" >> $GITHUB_ENV

      - name: üìä Create deployment summary
        run: |
          echo "=========================================="
          echo "üöÄ DEPLOYMENT COMPLETE - AUTH SERVICE"
          echo "=========================================="
          echo ""
          echo "üåê Service URL: http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337"
          echo "üìö API Documentation: http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/api"
          echo ""
          echo "üîó Available endpoints:"
          echo "  POST /auth/token      - Generate JWT token"
          echo "  POST /auth/validate   - Validate token"
          echo "  POST /employees       - Create employee (admin)"
          echo "  DELETE /employees/:cpf - Delete employee (admin)"
          echo ""
          echo "üïí Auto-destruction in: 5 minutes"
          echo "‚è∞ Destroy time: $(date -d '+5 minutes' '+%H:%M:%S')"
          echo ""
          echo "üìã Resources created:"
          echo "  ‚úÖ ECR Repository: ${{ env.ECR_REPOSITORY }}"
          echo "  ‚úÖ ECS Cluster: ${{ env.ECS_CLUSTER }}"
          echo "  ‚úÖ ECS Service: ${{ env.ECS_SERVICE }}"
          echo "  ‚úÖ RDS Instance: ${{ env.RDS_INSTANCE }}"
          echo "  ‚úÖ Security Group: ${{ steps.security-group.outputs.SG_ID }}"
          echo ""
          echo "=========================================="

      - name: üíæ Save deployment info as artifact
        run: |
          echo "Saving deployment information..."
          mkdir -p deployment-info
          
          cat > deployment-info/summary.md << EOF
          # Auth Service Deployment Summary
          
          **Deployment Time:** $(date)
          **Auto-Destroy Time:** $(date -d '+5 minutes')
          
          ## Service Information
          - **URL:** http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337
          - **Swagger Docs:** http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/api
          
          ## AWS Resources Created
          - **ECS Cluster:** ${{ env.ECS_CLUSTER }}
          - **ECS Service:** ${{ env.ECS_SERVICE }}
          - **RDS Instance:** ${{ env.RDS_INSTANCE }}
          - **Security Group:** ${{ steps.security-group.outputs.SG_ID }}
          
          ## Test Commands
          \`\`\`bash
          # Generate token
          curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/token \
            -H "Content-Type: application/json" \
            -d '{"cpf":"12345678901"}'
          
          # Validate token
          curl -X POST http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337/auth/validate \
            -H "Content-Type: application/json" \
            -d '{"token":"your-jwt-token"}'
          \`\`\`
          
          ## Important Notes
          - All resources will be automatically destroyed in 5 minutes
          - This is for academic/demo purposes only
          - Database password: [stored in GitHub Secrets]
          EOF
          
          # Salvar tamb√©m em JSON
          cat > deployment-info/details.json << EOF
          {
            "service": {
              "url": "http://${{ steps.get-ip.outputs.PUBLIC_IP }}:1337",
              "ip": "${{ steps.get-ip.outputs.PUBLIC_IP }}",
              "port": 1337
            },
            "aws_resources": {
              "ecr_repository": "${{ env.ECR_REPOSITORY }}",
              "ecs_cluster": "${{ env.ECS_CLUSTER }}",
              "ecs_service": "${{ env.ECS_SERVICE }}",
              "rds_instance": "${{ env.RDS_INSTANCE }}",
              "security_group": "${{ steps.security-group.outputs.SG_ID }}"
            },
            "timestamps": {
              "deployed_at": "$(date -Iseconds)",
              "destroy_at": "$(date -Iseconds -d '+5 minutes')"
            },
            "metadata": {
              "github_run_id": "${{ github.run_id }}",
              "repository": "${{ github.repository }}",
              "commit_sha": "${{ github.sha }}"
            }
          }
          EOF

  schedule-destruction:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ‚è∞ Schedule auto-destruction (5 minutes)
        run: |
          echo "‚è∞ Scheduling auto-destruction in 5 minutes..."
          
          # Criar script de destrui√ß√£o
          cat > destroy-resources.sh << 'EOF'
          #!/bin/bash
          echo "=========================================="
          echo "üßπ AUTO-DESTROY: CLEANING AWS RESOURCES"
          echo "=========================================="
          echo "Destroy time: $(date)"
          echo ""
          
          # Configurar vari√°veis (ser√£o passadas como par√¢metros)
          CLUSTER="$1"
          SERVICE="$2"
          RDS_INSTANCE="$3"
          SG_ID="$4"
          
          echo "üìã Resources to destroy:"
          echo "  - ECS Service: $SERVICE"
          echo "  - ECS Cluster: $CLUSTER"
          echo "  - RDS Instance: $RDS_INSTANCE"
          echo "  - Security Group: $SG_ID"
          echo ""
          
          # 1. Parar e deletar servi√ßo ECS
          echo "üîÑ Step 1: Stopping ECS service..."
          aws ecs update-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --desired-count 0
          
          sleep 10
          
          echo "üóëÔ∏è Deleting ECS service..."
          aws ecs delete-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --force
          
          # 2. Deletar cluster ECS
          echo "üóëÔ∏è Deleting ECS cluster..."
          aws ecs delete-cluster --cluster $CLUSTER
          
          # 3. Deletar inst√¢ncia RDS
          echo "üóëÔ∏è Deleting RDS instance..."
          aws rds delete-db-instance \
            --db-instance-identifier $RDS_INSTANCE \
            --skip-final-snapshot \
            --delete-automated-backups
          
          # 4. Deletar security group
          echo "üóëÔ∏è Deleting security group..."
          aws ec2 delete-security-group --group-id $SG_ID
          
          echo ""
          echo "‚úÖ‚úÖ‚úÖ ALL RESOURCES DESTROYED SUCCESSFULLY ‚úÖ‚úÖ‚úÖ"
          echo "Cleanup completed at: $(date)"
          EOF
          
          chmod +x destroy-resources.sh
          
          # Agendar destrui√ß√£o usando at command (execu√ß√£o local no runner)
          echo "bash ./destroy-resources.sh '${{ env.ECS_CLUSTER }}' '${{ env.ECS_SERVICE }}' '${{ env.RDS_INSTANCE }}' '${{ needs.deploy-infrastructure.outputs.SG_ID }}'" | at now + 5 minutes
          
          # Mostrar jobs agendados
          echo "üìÖ Scheduled jobs:"
          atq
          
          echo ""
          echo "‚è∞ Auto-destruction scheduled for: $(date -d '+5 minutes' '+%H:%M:%S')"

      - name: üìù Create destruction log file
        run: |
          echo "Creating destruction log..."
          cat > .github/aws/destruction-schedule.md << EOF
          # Auto-Destruction Schedule
          
          ## Resources Scheduled for Destruction
          
          **Scheduled Time:** $(date -d '+5 minutes')
          **Current Time:** $(date)
          
          ### Resources to be destroyed:
          1. **ECS Cluster:** ${{ env.ECS_CLUSTER }}
          2. **ECS Service:** ${{ env.ECS_SERVICE }}
          3. **RDS Instance:** ${{ env.RDS_INSTANCE }}
          4. **Security Group:** ${{ needs.deploy-infrastructure.outputs.SG_ID }}
          
          ### Destruction Commands:
          \`\`\`bash
          # Stop ECS service
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --desired-count 0
          
          # Delete ECS service
          aws ecs delete-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --force
          
          # Delete ECS cluster
          aws ecs delete-cluster --cluster ${{ env.ECS_CLUSTER }}
          
          # Delete RDS instance
          aws rds delete-db-instance --db-instance-identifier ${{ env.RDS_INSTANCE }} --skip-final-snapshot
          
          # Delete security group
          aws ec2 delete-security-group --group-id ${{ needs.deploy-infrastructure.outputs.SG_ID }}
          \`\`\`
          
          ## Notes
          - This is an academic/demo deployment
          - All resources are Free Tier eligible
          - Total cost: $0.00
          EOF

  verify-deployment:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: üåê Test service endpoints
        env:
          SERVICE_URL: http://${{ needs.deploy-infrastructure.outputs.PUBLIC_IP }}:1337
        run: |
          echo "üß™ Testing deployed service..."
          echo "Service URL: $SERVICE_URL"
          
          # Testar health endpoint (se existir)
          echo "1. Testing service availability..."
          if curl -s -f "$SERVICE_URL" --max-time 30; then
            echo "‚úÖ Service is responding"
          else
            echo "‚ö†Ô∏è Service not responding on root, checking port..."
          fi
          
          # Testar Swagger docs
          echo "2. Checking Swagger documentation..."
          if curl -s -f "$SERVICE_URL/api" --max-time 30 > /dev/null; then
            echo "‚úÖ Swagger docs available"
          else
            echo "‚ö†Ô∏è Swagger docs not available"
          fi
          
          echo ""
          echo "üéâ Deployment verification complete!"
          echo "Service is running at: $SERVICE_URL"

  final-summary:
    needs: [deploy-infrastructure, schedule-destruction, verify-deployment]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: üìä Create final deployment summary
        env:
          PUBLIC_IP: ${{ needs.deploy-infrastructure.outputs.PUBLIC_IP }}
        run: |
          echo "================================================"
          echo "üéâ CI/CD PIPELINE COMPLETE - AUTH SERVICE"
          echo "================================================"
          echo ""
          echo "‚úÖ ALL STEPS COMPLETED SUCCESSFULLY"
          echo ""
          echo "üìä PIPELINE SUMMARY:"
          echo "  1. ‚úÖ Tests & SonarQube Analysis"
          echo "  2. ‚úÖ Docker Image Built & Pushed to ECR"
          echo "  3. ‚úÖ AWS Infrastructure Deployed"
          echo "  4. ‚úÖ Auto-Destruction Scheduled (5 minutes)"
          echo "  5. ‚úÖ Service Verification"
          echo ""
          echo "üåê YOUR SERVICE IS LIVE AT:"
          echo "  http://${{ env.PUBLIC_IP }}:1337"
          echo ""
          echo "üìö API Documentation:"
          echo "  http://${{ env.PUBLIC_IP }}:1337/api"
          echo ""
          echo "üïí AUTO-DESTRUCTION:"
          echo "  Scheduled: $(date -d '+5 minutes' '+%H:%M:%S')"
          echo ""
          echo "üîó QUICK TEST:"
          echo "  curl -X POST http://${{ env.PUBLIC_IP }}:1337/auth/token \\"
          echo "    -H \"Content-Type: application/json\" \\"
          echo "    -d '{\"cpf\":\"12345678901\"}'"
          echo ""
          echo "================================================"
          echo "üé• RECORD YOUR SCREENSHOWING ALL GREEN CHECKS! üé•"
          echo "================================================"