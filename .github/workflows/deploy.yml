name: Deploy to AWS ECS with Auto-Destroy

on:
  pull_request:
    types: [closed]
    branches: [main]

  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "main"
        type: string
      confirm:
        description: 'Type "yes" to confirm deployment'
        required: true
        type: string
        default: "yes"

env:
  AWS_REGION: "us-east-1"
  ECR_REPOSITORY: "auth-service"
  ECS_CLUSTER: "auth-cluster"
  CONTAINER_NAME: "auth-container"
  RDS_INSTANCE: "auth-db-${{ github.run_id }}"
  ECS_SERVICE: "auth-service-${{ github.run_id }}"

jobs:
  # ============================================
  # JOB 1: Verificar se foi MERGE (nÃ£o apenas closed)
  # ============================================
  check-merge:
    name: ğŸ” Check Merge Status
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      pr_title: ${{ github.event.pull_request.title }}
      merged_by: ${{ github.event.pull_request.merged_by.login }}

    steps:
      - name: ğŸ“‹ Verify if PR was merged
        id: check
        run: |
          echo "PR Action: ${{ github.event.action }}"
          echo "PR Merged: ${{ github.event.pull_request.merged }}"
          echo "PR Title: ${{ github.event.pull_request.title }}"

          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "âœ… PR WAS MERGED INTO MAIN - DEPLOYMENT WILL RUN"
            echo "Merged by: ${{ github.event.pull_request.merged_by.login }}"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ PR was CLOSED without merge - SKIPPING DEPLOY"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # ============================================
  # JOB 2: Build Docker Image
  # ============================================
  build-docker:
    name: ğŸ³ Build & Push Docker Image
    needs: check-merge
    if: |
      (github.event_name == 'pull_request' && needs.check-merge.outputs.should_deploy == 'true') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.confirm == 'yes')
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      ecr_registry: ${{ steps.build.outputs.ecr_registry }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: ğŸ‰ Deployment trigger info
        run: |
          echo "========================================"
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ğŸ‰ AUTOMATED DEPLOYMENT AFTER PR MERGE"
            echo "PR: ${{ needs.check-merge.outputs.pr_title }}"
            echo "Merged by: ${{ needs.check-merge.outputs.merged_by }}"
          else
            echo "ğŸ® MANUAL DEPLOYMENT"
            echo "Triggered by: ${{ github.actor }}"
          fi
          echo "Run ID: ${{ github.run_id }}"
          echo "========================================"

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ³ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Create ECR Repository if not exists
        run: |
          echo "ğŸ—ï¸ Checking if ECR repository exists..."

          # Verificar se o repositÃ³rio jÃ¡ existe
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} > /dev/null 2>&1; then
            echo "âœ… Repository already exists"
          else
            echo "ğŸ“¦ Creating ECR repository..."
            aws ecr create-repository \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --image-tag-mutability MUTABLE \
              --tags Key=Project,Value=Academic
            echo "âœ… Repository created successfully"
          fi

      - name: ğŸ—ï¸ Build Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: deploy-${{ github.run_id }}
        run: |
          echo "ğŸ”¨ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .

          echo "ğŸ“¤ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          echo "âœ… Image pushed successfully!"
          echo "Registry: $ECR_REGISTRY"
          echo "Repository: $ECR_REPOSITORY"
          echo "Tag: $IMAGE_TAG"

          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 3: Deploy na AWS
  # ============================================
  deploy-aws:
    name: ğŸš€ Deploy to AWS ECS
    needs: build-docker
    if: success()
    runs-on: ubuntu-latest
    timeout-minutes: 25
    outputs:
      public_ip: ${{ steps.get-ip.outputs.PUBLIC_IP }}
      service_url: ${{ steps.get-url.outputs.SERVICE_URL }}
      health_check: ${{ steps.test-app.outputs.HEALTH_CHECK }}

    steps:
      - name: ğŸ“‹ Starting AWS deployment
        run: |
          echo "========================================"
          echo "ğŸš€ DEPLOYING TO AWS ECS FARGATE"
          echo "========================================"
          echo "Run ID: ${{ github.run_id }}"
          echo "Image: ${{ needs.build-docker.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-docker.outputs.image_tag }}"
          echo "========================================"

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ========== RDS DATABASE ==========
      - name: ğŸ—„ï¸ Create PostgreSQL Database
        id: create-db
        run: |
          echo "ğŸ—„ï¸ Creating RDS PostgreSQL instance..."

          # Gerar senha segura
          DB_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 16)
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_OUTPUT

          # Criar instÃ¢ncia RDS
          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --allocated-storage 20 \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --backup-retention-period 0 \
            --publicly-accessible \
            --no-multi-az \
            --no-auto-minor-version-upgrade \
            --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true Key=RunId,Value=${{ github.run_id }}

          echo "âœ… RDS instance creation started: ${{ env.RDS_INSTANCE }}"

      - name: â³ Wait for database to be available
        run: |
          echo "â³ Waiting for database to be ready (max 10 minutes)..."

          for i in {1..30}; do
            STATUS=$(aws rds describe-db-instances \
              --db-instance-identifier ${{ env.RDS_INSTANCE }} \
              --query "DBInstances[0].DBInstanceStatus" \
              --output text 2>/dev/null || echo "creating")
            
            echo "Attempt $i/30 - Status: $STATUS"
            
            if [ "$STATUS" = "available" ]; then
              echo "âœ… Database is ready!"
              break
            fi
            
            if [ "$i" -eq 30 ]; then
              echo "âŒ Database not ready in time. Continuing anyway..."
            fi
            
            sleep 20
          done

      - name: ğŸ“ Get database endpoint
        id: db-endpoint
        run: |
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text 2>/dev/null || echo "not-ready")

          echo "RDS_ENDPOINT=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "ğŸ“Œ Database endpoint: $ENDPOINT"

      # ========== ECS CLUSTER ==========
      - name: ğŸ³ Create ECS Cluster
        run: |
          echo "ğŸ³ Creating ECS cluster..."

          aws ecs create-cluster \
            --cluster-name ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}

          echo "âœ… ECS cluster created: ${{ env.ECS_CLUSTER }}-${{ github.run_id }}"

      # ========== IAM ROLE ==========
      - name: ğŸ› ï¸ Create ECS Task Execution Role
        id: create-role
        run: |
          echo "ğŸ› ï¸ Creating/verifying ECS task execution role..."

          ROLE_NAME="ecsTaskExecutionRole-${{ github.run_id }}"

          # Criar trust policy para ECS
          cat > trust-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "ecs-tasks.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          }
          EOF

          # Tentar criar a role
          if aws iam create-role \
            --role-name $ROLE_NAME \
            --assume-role-policy-document file://trust-policy.json \
            --description "ECS Task Execution Role for Auto-Destroy demo" \
            --tags Key=Project,Value=Academic Key=AutoDestroy,Value=true Key=RunId,Value=${{ github.run_id }} 2>/dev/null; then
            
            echo "âœ… Role created: $ROLE_NAME"
            
            # Anexar a polÃ­tica padrÃ£o do ECS
            aws iam attach-role-policy \
              --role-name $ROLE_NAME \
              --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
            
          else
            echo "â„¹ï¸ Role already exists or error occurred, continuing..."
          fi

          # Obter ARN da role (tentar de vÃ¡rias formas)
          ROLE_ARN=$(aws iam get-role --role-name $ROLE_NAME --query 'Role.Arn' --output text 2>/dev/null || \
            aws iam list-roles --query "Roles[?RoleName=='$ROLE_NAME'].Arn" --output text 2>/dev/null || \
            echo "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/$ROLE_NAME")

          echo "ROLE_ARN=$ROLE_ARN" >> $GITHUB_OUTPUT
          echo "Role ARN: $ROLE_ARN"

      # ========== SECURITY GROUPS ==========
      - name: ğŸ›¡ï¸ Create Security Group for ECS
        id: create-ecs-sg
        run: |
          echo "ğŸ›¡ï¸ Creating security group for ECS..."

          # Obter VPC padrÃ£o
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)

          echo "Using VPC: $VPC_ID"

          # Criar security group
          SG_ID=$(aws ec2 create-security-group \
            --group-name "auth-ecs-sg-${{ github.run_id }}" \
            --description "Auth Service ECS Security Group" \
            --vpc-id $VPC_ID \
            --tag-specifications 'ResourceType=security-group,Tags=[{Key=Project,Value=Academic},{Key=AutoDestroy,Value=true},{Key=RunId,Value=${{ github.run_id }}}]' \
            --query 'GroupId' \
            --output text)

          echo "ECS_SG_ID=$SG_ID" >> $GITHUB_OUTPUT

          # Permitir porta 1337 de qualquer lugar
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 1337 \
            --cidr 0.0.0.0/0

          echo "âœ… ECS Security group created: $SG_ID"
          echo "Port 1337 opened to public"

      - name: ğŸ” Configure RDS Security Group
        id: rds-sg
        run: |
          echo "ğŸ” Configuring RDS security group..."

          # Obter security group do RDS
          sleep 10  # Aguardar RDS estar disponÃ­vel

          RDS_SG_ID=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_INSTANCE }} \
            --query 'DBInstances[0].VpcSecurityGroups[0].VpcSecurityGroupId' \
            --output text 2>/dev/null || echo "")

          if [ -n "$RDS_SG_ID" ]; then
            echo "RDS Security Group ID: $RDS_SG_ID"
            
            # Permitir trÃ¡fego do ECS no RDS (porta 5432)
            aws ec2 authorize-security-group-ingress \
              --group-id $RDS_SG_ID \
              --protocol tcp \
              --port 5432 \
              --source-group ${{ steps.create-ecs-sg.outputs.ECS_SG_ID }} \
              --tag-specifications 'ResourceType=security-group-rule,Tags=[{Key=Project,Value=Academic},{Key=AutoDestroy,Value=true},{Key=RunId,Value=${{ github.run_id }}}]' 2>/dev/null || \
              echo "â„¹ï¸ Rule may already exist, continuing..."
            
            echo "âœ… RDS security group configured"
          else
            echo "âš ï¸ Could not get RDS security group, continuing anyway..."
          fi

      # ========== TASK DEFINITION ==========
      - name: ğŸ“„ Create Task Definition
        id: create-task
        env:
          ECR_REGISTRY: ${{ needs.build-docker.outputs.ecr_registry }}
          IMAGE_TAG: ${{ needs.build-docker.outputs.image_tag }}
          RDS_ENDPOINT: ${{ steps.db-endpoint.outputs.RDS_ENDPOINT }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          ADMIN_SECRET_KEY: ${{ secrets.ADMIN_SECRET_KEY }}
        run: |
          echo "ğŸ“„ Creating task definition..."

          # Construir DATABASE_URL corretamente
          DB_PASSWORD="${{ env.DB_PASSWORD }}"
          DATABASE_URL="postgresql://postgres:${DB_PASSWORD}@${RDS_ENDPOINT}:5432/postgres?schema=public"

          echo "DATABASE_URL (masked): postgresql://postgres:******@${RDS_ENDPOINT}:5432/postgres?schema=public"

          # Criar task definition JSON
          cat > task-definition.json << EOF
          {
            "family": "auth-task-${{ github.run_id }}",
            "networkMode": "awsvpc",
            "executionRoleArn": "${{ steps.create-role.outputs.ROLE_ARN }}",
            "containerDefinitions": [
              {
                "name": "${{ env.CONTAINER_NAME }}",
                "image": "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG",
                "portMappings": [
                  {
                    "containerPort": 1337,
                    "hostPort": 1337,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "DATABASE_URL",
                    "value": "${DATABASE_URL}"
                  },
                  {
                    "name": "PORT",
                    "value": "1337"
                  },
                  {
                    "name": "HOST",
                    "value": "0.0.0.0"
                  },
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "$JWT_SECRET"
                  },
                  {
                    "name": "ADMIN_SECRET_KEY",
                    "value": "$ADMIN_SECRET_KEY"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/auth-service",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:1337/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ],
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "tags": [
              {"key": "Project", "value": "Academic"},
              {"key": "AutoDestroy", "value": "true"},
              {"key": "RunId", "value": "${{ github.run_id }}"}
            ]
          }
          EOF

          echo "Task definition content (sensitive data masked):"
          sed 's/postgres:[^@]*@/postgres:******@/g; s/"value": "[^"]*JWT[^"]*"/"value": "******"/g; s/"value": "[^"]*ADMIN[^"]*"/"value": "******"/g' task-definition.json

          # Registrar task definition
          TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "TASK_ARN=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "âœ… Task definition registered: $TASK_ARN"

      # ========== ECS SERVICE ==========
      - name: ğŸš€ Create ECS Service
        run: |
          echo "ğŸš€ Creating ECS service..."

          # Obter VPC padrÃ£o
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)

          # Obter subnets pÃºblicas do VPC
          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=map-public-ip-on-launch,Values=true" \
            --query 'Subnets[0:2].SubnetId' \
            --output text)

          if [ -z "$SUBNETS" ]; then
            echo "âš ï¸ No public subnets found, using any subnet"
            SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[0:2].SubnetId' \
              --output text)
          fi

          SUBNET_1=$(echo $SUBNETS | cut -d' ' -f1)
          SUBNET_2=$(echo $SUBNETS | cut -d' ' -f2)

          echo "Using subnets: $SUBNET_1, $SUBNET_2"

          # Criar serviÃ§o ECS CORRETAMENTE com desired-count 1
          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.create-task.outputs.TASK_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --platform-version "LATEST" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],assignPublicIp=ENABLED,securityGroups=[${{ steps.create-ecs-sg.outputs.ECS_SG_ID }}]}" \
            --enable-execute-command \
            --health-check-grace-period-seconds 120 \
            --tags key=Project,value=Academic key=AutoDestroy,value=true key=RunId,value=${{ github.run_id }}

          echo "âœ… ECS service created: ${{ env.ECS_SERVICE }}"

      # ========== WAIT FOR SERVICE ==========
      - name: â³ Wait for service to start
        id: wait-service
        run: |
          echo "â³ Waiting for service to start (up to 5 minutes)..."

          MAX_ATTEMPTS=30
          ATTEMPT=0
          SERVICE_READY=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Verificar status do serviÃ§o
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0]' \
              --output json 2>/dev/null || echo "{}")
            
            RUNNING_COUNT=$(echo $SERVICE_STATUS | jq -r '.runningCount // 0')
            PENDING_COUNT=$(echo $SERVICE_STATUS | jq -r '.pendingCount // 0')
            
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Running: $RUNNING_COUNT, Pending: $PENDING_COUNT"
            
            if [ "$RUNNING_COUNT" -ge 1 ]; then
              echo "âœ… Service is running!"
              SERVICE_READY=true
              break
            fi
            
            # Verificar se hÃ¡ tarefas que falharam
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --query 'taskArns' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$TASK_ARNS" ]; then
              for TASK_ARN in $TASK_ARNS; do
                TASK_STATUS=$(aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                  --tasks $TASK_ARN \
                  --query 'tasks[0].lastStatus' \
                  --output text 2>/dev/null || echo "UNKNOWN")
                
                if [ "$TASK_STATUS" = "STOPPED" ]; then
                  echo "âš ï¸ Task stopped, checking reason..."
                  STOP_REASON=$(aws ecs describe-tasks \
                    --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                    --tasks $TASK_ARN \
                    --query 'tasks[0].containers[0].reason' \
                    --output text 2>/dev/null || echo "Unknown")
                  echo "Stop reason: $STOP_REASON"
                fi
              done
            fi
            
            if [ "$ATTEMPT" -eq $MAX_ATTEMPTS ]; then
              echo "âš ï¸ Service failed to start in time"
              echo "ğŸ“‹ Checking service events for errors:"
              aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                --services ${{ env.ECS_SERVICE }} \
                --query 'services[0].events[?contains(message, `ERROR`) || contains(message, `error`) || contains(message, `failed`) || contains(message, `unhealthy`)] | reverse(slice(@, 0, 5))' \
                --output json | jq -r '.[] | .message' 2>/dev/null || echo "No error events found"
            fi
            
            sleep 10
          done

          if [ "$SERVICE_READY" = false ]; then
            echo "âŒ Service failed to start properly"
            echo "SERVICE_STATUS=failed" >> $GITHUB_OUTPUT
          else
            echo "SERVICE_STATUS=running" >> $GITHUB_OUTPUT
          fi

      # ========== GET PUBLIC IP ==========
      - name: ğŸŒ Get Public IP
        id: get-ip
        run: |
          echo "ğŸŒ Getting public IP address..."

          MAX_ATTEMPTS=15
          ATTEMPT=0
          PUBLIC_IP=""

          while [ -z "$PUBLIC_IP" ] && [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS to get public IP..."
            
            # Obter task ARN
            TASK_ARN=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --query 'taskArns[0]' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$TASK_ARN" ]; then
              echo "Found task: $TASK_ARN"
              
              # Obter ENI ID da task
              ENI_ID=$(aws ecs describe-tasks \
                --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                --tasks $TASK_ARN \
                --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ENI_ID" ]; then
                echo "Found ENI: $ENI_ID"
                
                # Obter IP pÃºblico
                PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $ENI_ID \
                  --query 'NetworkInterfaces[0].Association.PublicIp' \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
                  echo "âœ… Public IP found: $PUBLIC_IP"
                  break
                fi
              fi
            fi
            
            if [ "$ATTEMPT" -eq $MAX_ATTEMPTS ]; then
              echo "âš ï¸ Could not retrieve public IP"
              PUBLIC_IP="IP_NOT_AVAILABLE"
            fi
            
            sleep 10
          done

          if [ -z "$PUBLIC_IP" ]; then
            PUBLIC_IP="IP_NOT_AVAILABLE"
          fi

          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: ğŸ“Š Check ECS Task Status & Logs
        id: check-task-logs
        run: |
          echo "ğŸ“Š Checking ECS task status and logs..."

          # Obter task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --query 'taskArns[0]' \
            --output text 2>/dev/null || echo "")

          if [ -z "$TASK_ARN" ]; then
            echo "âŒ No tasks found for service"
            exit 0
          fi

          echo "Task ARN: $TASK_ARN"

          # Obter status da task
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].lastStatus' \
            --output text 2>/dev/null || echo "UNKNOWN")

          echo "Task Status: $TASK_STATUS"

          # Se a task estÃ¡ rodando, obter mais detalhes
          if [ "$TASK_STATUS" = "RUNNING" ]; then
            echo "âœ… Task is running"
            
            # Obter health status
            HEALTH_STATUS=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --tasks $TASK_ARN \
              --query 'tasks[0].healthStatus' \
              --output text 2>/dev/null || echo "UNKNOWN")
            
            echo "Health Status: $HEALTH_STATUS"
            
            # Obter motivo se a task nÃ£o estiver saudÃ¡vel
            if [ "$HEALTH_STATUS" != "HEALTHY" ]; then
              echo "âš ï¸ Task is not healthy, checking containers..."
              
              CONTAINERS=$(aws ecs describe-tasks \
                --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
                --tasks $TASK_ARN \
                --query 'tasks[0].containers[]' \
                --output json 2>/dev/null || echo "[]")
              
              echo "Containers status:"
              echo $CONTAINERS | jq -r '.[] | "  - \(.name): \(.lastStatus) (Exit: \(.exitCode), Reason: \(.reason))"'
            fi
          elif [ "$TASK_STATUS" = "STOPPED" ]; then
            echo "âŒ Task is stopped, checking reason..."
            
            STOP_REASON=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --tasks $TASK_ARN \
              --query 'tasks[0].containers[0].reason' \
              --output text 2>/dev/null || echo "Unknown")
            
            EXIT_CODE=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --tasks $TASK_ARN \
              --query 'tasks[0].containers[0].exitCode' \
              --output text 2>/dev/null || echo "Unknown")
            
            echo "Stop Reason: $STOP_REASON"
            echo "Exit Code: $EXIT_CODE"
            
            # Tentar executar comando na task para diagnÃ³stico
            echo "ğŸ”„ Attempting to execute diagnostic command..."
            aws ecs execute-command \
              --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
              --task $TASK_ARN \
              --command "ps aux" \
              --interactive 2>/dev/null || echo "Execute command not available"
          else
            echo "â„¹ï¸ Task status: $TASK_STATUS"
          fi

          # Verificar eventos do serviÃ§o
          echo "ğŸ“‹ Service events (last 5):"
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }}-${{ github.run_id }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].events[0:5]' \
            --output json | jq -r '.[] | "  [\(.createdAt)] \(.message)"' 2>/dev/null || echo "  No events found"

      # ========== TEST APPLICATION ==========
      - name: ğŸ§ª Test application endpoint
        id: test-app
        run: |
          echo "ğŸ§ª Testing application endpoint with intelligent checks..."

          PUBLIC_IP="${{ steps.get-ip.outputs.PUBLIC_IP }}"

          if [ "$PUBLIC_IP" = "IP_NOT_AVAILABLE" ] || [ -z "$PUBLIC_IP" ]; then
            echo "âš ï¸ IP not available, skipping health check"
            echo "HEALTH_CHECK=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Testing application at: http://$PUBLIC_IP:1337"

          # Lista de endpoints possÃ­veis para testar (em ordem de prioridade)
          ENDPOINTS=(
            "/"                    # PÃ¡gina raiz
            "/health"              # Endpoint de health padrÃ£o
            "/api"                 # API documentation
            "/api/health"          # Health da API
            "/auth/health"         # Health do auth
            "/docs"                # DocumentaÃ§Ã£o
            "/swagger"             # Swagger
            "/status"              # Status
            "/ping"                # Ping simples
            "/v1/health"           # Health v1
          )

          # Testar tambÃ©m portas alternativas
          PORTS=("1337" "3000" "8080" "80" "443")

          MAX_RETRIES=10
          RETRY=0
          HEALTH_CHECK="failed"
          ACTUAL_ENDPOINT=""
          ACTUAL_PORT="1337"

          echo "ğŸ” Starting intelligent health check..."

          # Primeiro, verificar se a porta 1337 estÃ¡ aberta
          echo "Checking if port 1337 is open..."
          if nc -z -w 5 "$PUBLIC_IP" 1337 2>/dev/null; then
            echo "âœ… Port 1337 is open and accepting connections"
            ACTUAL_PORT="1337"
          else
            echo "âš ï¸ Port 1337 is not responding, trying alternative ports..."
            
            for PORT in "${PORTS[@]}"; do
              if [ "$PORT" != "1337" ]; then
                echo "  Trying port $PORT..."
                if timeout 2 nc -z "$PUBLIC_IP" "$PORT" 2>/dev/null; then
                  echo "âœ… Port $PORT is open!"
                  ACTUAL_PORT="$PORT"
                  break
                fi
              fi
            done
          fi

          # Se encontramos uma porta aberta, testar endpoints
          if [ "$ACTUAL_PORT" != "1337" ]; then
            echo "â„¹ï¸ Application might be running on port: $ACTUAL_PORT"
          fi

          # Testar endpoints com retry inteligente
          while [ $RETRY -lt $MAX_RETRIES ] && [ "$HEALTH_CHECK" != "passed" ]; do
            RETRY=$((RETRY + 1))
            
            echo ""
            echo "Health check attempt $RETRY/$MAX_RETRIES..."
            
            # Para cada endpoint
            for ENDPOINT in "${ENDPOINTS[@]}"; do
              echo "  Testing: http://$PUBLIC_IP:$ACTUAL_PORT$ENDPOINT"
              
              # Tentar com timeout e vÃ¡rias opÃ§Ãµes de curl
              RESPONSE=$(timeout 5 curl -s -o /dev/null -w "%{http_code} %{content_type}" \
                "http://$PUBLIC_IP:$ACTUAL_PORT$ENDPOINT" 2>/dev/null || echo "000")
              
              RESPONSE_CODE=$(echo $RESPONSE | cut -d' ' -f1)
              CONTENT_TYPE=$(echo $RESPONSE | cut -d' ' -f2)
              
              if [ "$RESPONSE_CODE" = "200" ] || [ "$RESPONSE_CODE" = "201" ] || [ "$RESPONSE_CODE" = "204" ]; then
                echo "    âœ… Success! Response code: $RESPONSE_CODE"
                HEALTH_CHECK="passed"
                ACTUAL_ENDPOINT="$ENDPOINT"
                break 2
              elif [ "$RESPONSE_CODE" = "404" ] || [ "$RESPONSE_CODE" = "401" ] || [ "$RESPONSE_CODE" = "403" ]; then
                echo "    â„¹ï¸ Endpoint exists but returned: $RESPONSE_CODE"
                HEALTH_CHECK="partial"
                ACTUAL_ENDPOINT="$ENDPOINT"
              elif [ "$RESPONSE_CODE" != "000" ] && [ "$RESPONSE_CODE" != "" ]; then
                echo "    âš ï¸ Got response: $RESPONSE_CODE"
                HEALTH_CHECK="responding"
                ACTUAL_ENDPOINT="$ENDPOINT"
              fi
            done
            
            # Se ainda nÃ£o encontrou, esperar um pouco mais entre tentativas
            if [ "$HEALTH_CHECK" != "passed" ]; then
              WAIT_TIME=$((RETRY * 2))  # Backoff exponencial
              echo "  Waiting $WAIT_TIME seconds before next attempt..."
              sleep $WAIT_TIME
              
              # Na Ãºltima tentativa, fazer diagnÃ³stico mais detalhado
              if [ $RETRY -eq $MAX_RETRIES ]; then
                echo ""
                echo "ğŸ“‹ Diagnostic information:"
                echo "  Public IP: $PUBLIC_IP"
                echo "  Port tested: $ACTUAL_PORT"
                echo "  Endpoints tested: ${ENDPOINTS[*]}"
                
                # Testar conectividade bÃ¡sica
                echo ""
                echo "ğŸ” Basic connectivity tests:"
                echo "  - Ping test:"
                ping -c 2 -W 2 "$PUBLIC_IP" 2>/dev/null && echo "    âœ… Host is reachable" || echo "    âŒ Host unreachable"
                
                echo "  - Port scan (common ports):"
                for PORT in 1337 80 443 3000 8080; do
                  timeout 1 bash -c "echo >/dev/tcp/$PUBLIC_IP/$PORT" 2>/dev/null && \
                    echo "    âœ… Port $PORT is open" || \
                    echo "    âŒ Port $PORT is closed"
                done
                
                # Verificar se hÃ¡ serviÃ§o rodando com netstat remoto (usando nmap se disponÃ­vel)
                echo "  - Service detection:"
                if command -v nmap &> /dev/null; then
                  echo "    Scanning for services on $PUBLIC_IP..."
                  nmap -p 1337,80,443,3000,8080 "$PUBLIC_IP" 2>/dev/null | grep -E "(PORT|open|closed|filtered)" || true
                fi
              fi
            fi
          done

          # Resultado final
          echo ""
          if [ "$HEALTH_CHECK" = "passed" ]; then
            echo "ğŸ‰ HEALTH CHECK PASSED!"
            echo "âœ… Application is responding at: http://$PUBLIC_IP:$ACTUAL_PORT$ACTUAL_ENDPOINT"
          elif [ "$HEALTH_CHECK" = "partial" ] || [ "$HEALTH_CHECK" = "responding" ]; then
            echo "âš ï¸ APPLICATION IS RUNNING BUT WITH ISSUES"
            echo "â„¹ï¸ Got response at: http://$PUBLIC_IP:$ACTUAL_PORT$ACTUAL_ENDPOINT"
            HEALTH_CHECK="partial"
          else
            echo "âŒ HEALTH CHECK FAILED"
            echo "Application is not responding to any endpoint"
            HEALTH_CHECK="failed"
          fi

          echo "HEALTH_CHECK=$HEALTH_CHECK" >> $GITHUB_OUTPUT
          echo "ACTUAL_PORT=$ACTUAL_PORT" >> $GITHUB_OUTPUT
          echo "ACTUAL_ENDPOINT=$ACTUAL_ENDPOINT" >> $GITHUB_OUTPUT

      # ========== CREATE SERVICE URL ==========
      - name: ğŸ”— Create service URL
        id: get-url
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.PUBLIC_IP }}"
          HEALTH_CHECK="${{ steps.test-app.outputs.HEALTH_CHECK }}"

          if [ "$PUBLIC_IP" != "IP_NOT_AVAILABLE" ] && [ -n "$PUBLIC_IP" ]; then
            SERVICE_URL="http://$PUBLIC_IP:1337"
            echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_OUTPUT
            echo "Service URL: $SERVICE_URL"
            echo "Health check: $HEALTH_CHECK"
          else
            echo "SERVICE_URL=http://IP_NOT_AVAILABLE:1337" >> $GITHUB_OUTPUT
            echo "âš ï¸ Service URL not available"
          fi

      # ========== AUTO-DESTRUCTION ==========
      - name: â° Schedule Auto-Destruction
        run: |
          echo "â° Scheduling auto-destruction in 5 minutes..."

          # Criar script de destruiÃ§Ã£o melhorado
          cat > /tmp/destroy-resources.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "========================================"
          echo "ğŸ§¹ AUTO-DESTRUCTION INITIATED"
          echo "========================================"
          echo "Time: $(date)"
          echo "Run ID: $1"
          echo ""

          # Configurar credenciais AWS
          export AWS_ACCESS_KEY_ID="$2"
          export AWS_SECRET_ACCESS_KEY="$3"
          export AWS_REGION="$4"

          # Esperar 5 minutos (300 segundos)
          echo "â³ Waiting 5 minutes before cleanup..."
          sleep 300

          echo "ğŸ”§ Starting resource cleanup..."
          echo ""

          # FunÃ§Ã£o para log com timestamp
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }

          # 1. Parar e deletar serviÃ§o ECS
          log "Step 1: Stopping ECS service..."
          aws ecs update-service \
            --cluster "$5" \
            --service "$6" \
            --desired-count 0 2>/dev/null && \
            log "  Service scaled to 0" || \
            log "  Service already stopped or not found"

          sleep 10

          log "Step 2: Deleting ECS service..."
          aws ecs delete-service \
            --cluster "$5" \
            --service "$6" \
            --force 2>/dev/null && \
            log "  Service deleted" || \
            log "  Service already deleted or not found"

          # 2. Deletar cluster ECS
          log "Step 3: Deleting ECS cluster..."
          aws ecs delete-cluster --cluster "$5" 2>/dev/null && \
            log "  Cluster deleted" || \
            log "  Cluster already deleted or not found"

          # 3. Deletar instÃ¢ncia RDS
          log "Step 4: Deleting RDS instance..."
          aws rds delete-db-instance \
            --db-instance-identifier "$7" \
            --skip-final-snapshot \
            --delete-automated-backups 2>/dev/null && \
            log "  RDS deletion initiated" || \
            log "  RDS already deleted or not found"

          # 4. Deletar security group
          log "Step 5: Deleting security group..."
          aws ec2 delete-security-group --group-id "$8" 2>/dev/null && \
            log "  Security group deleted" || \
            log "  Security group already deleted or not found"

          echo ""
          echo "âœ…âœ…âœ… CLEANUP COMPLETE âœ…âœ…âœ…"
          echo "All resources destroyed at: $(date)"
          echo "========================================"
          EOF

          chmod +x /tmp/destroy-resources.sh

          # Executar em background
          nohup /tmp/destroy-resources.sh \
            "${{ github.run_id }}" \
            "${{ secrets.AWS_ACCESS_KEY_ID }}" \
            "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            "${{ env.AWS_REGION }}" \
            "${{ env.ECS_CLUSTER }}-${{ github.run_id }}" \
            "${{ env.ECS_SERVICE }}" \
            "${{ env.RDS_INSTANCE }}" \
            "${{ steps.create-ecs-sg.outputs.ECS_SG_ID }}" \
            > /tmp/destroy-log-${{ github.run_id }}.txt 2>&1 &

          echo "âœ… Auto-destruction scheduled successfully"
          echo "ğŸ•’ Will execute at: $(date -d '+5 minutes' '+%H:%M:%S')"
          echo "ğŸ“ Log file: /tmp/destroy-log-${{ github.run_id }}.txt"

      # ========== DEPLOYMENT SUMMARY ==========
