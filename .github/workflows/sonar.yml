name: SonarQube Analysis - 80% Coverage per File

on:
  pull_request:
    branches: [main, master]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write  

env:
  MIN_COVERAGE: 80
  IGNORE_PATTERNS: "**/*.dto.ts,**/*.enum.ts,**/value-objects/**,**/*.interface.ts,**/main.ts,**/index.ts,**/*.config.ts,**/migrations/**,**/seeders/**,**/*.module.ts"

jobs:
  build-and-test:
    name: ğŸ—ï¸ Build & Test
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    timeout-minutes: 15
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: ğŸ“¦ Install dependencies
        run: npm ci
        
      - name: ğŸ—ï¸ Build application
        run: npm run build  
        
      - name: ğŸ§ª Run tests with coverage
        id: run-tests
        run: |
          echo "Running tests with coverage..."
          npm test -- --coverage --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text
          
          # Verifica se o lcov.info foi gerado
          if [ -f "coverage/lcov.info" ]; then
            echo "âœ… lcov.info generated successfully"
            echo "File size: $(wc -l < coverage/lcov.info) lines"
          else
            echo "âŒ ERROR: lcov.info not generated!"
            ls -la coverage/ 2>/dev/null || echo "No coverage directory"
            exit 1
          fi
          
      - name: âœ… Report job completion
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Job 'build-and-test' completed successfully"
          else
            echo "âŒ Job 'build-and-test' failed"
          fi

  verify-coverage-per-file:
    name: ğŸ”¬ Verify 80% Coverage PER FILE
    needs: build-and-test
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    timeout-minutes: 10
    
    outputs:
      coverage_passed: ${{ steps.check-coverage.outputs.passed }}
      failed_files: ${{ steps.check-coverage.outputs.failed_files }}
      failed_count: ${{ steps.check-coverage.outputs.failed_count }}
      coverage_summary: ${{ steps.check-coverage.outputs.coverage_summary }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: ğŸ“¦ Install dependencies
        run: npm ci
        
      - name: ğŸ“Š Generate detailed coverage report
        run: |
          npm test -- --coverage \
            --coverageReporters=json-summary \
            --coverageReporters=lcov \
            --coverageReporters=text \
            --coverageReporters=html

      - name: ğŸ” Validate 80% Coverage PER FILE
        id: check-coverage
        run: |
          # Script Node.js que valida CADA ARQUIVO individualmente
          node -e "
          const fs = require('fs');
          const path = require('path');
          
          console.log('ğŸ” VALIDAÃ‡ÃƒO: 80% de cobertura POR ARQUIVO');
          console.log('===========================================');
          console.log('MÃ­nimo exigido por arquivo: 80%');
          console.log('Arquivos ignorados: DTOs, Enums, Interfaces, Value Objects, Main, Configs\\n');
          
          // 1. CARREGAR RELATÃ“RIO
          const summaryPath = './coverage/coverage-summary.json';
          if (!fs.existsSync(summaryPath)) {
            console.error('âŒ RelatÃ³rio de cobertura nÃ£o encontrado!');
            process.exit(1);
          }
          
          const coverageData = require(summaryPath);
          const MIN_COVERAGE = 80;
          const totalCoverage = coverageData.total?.lines?.pct || 0;
          
          // 2. PADRÃ•ES DE IGNORAÃ‡ÃƒO
          const IGNORE_PATTERNS = [
            /\.dto\.ts$/i,
            /\.enum\.ts$/i,
            /\.interface\.ts$/i,
            /\/value-objects\//i,
            /main\.ts$/i,
            /index\.ts$/i,
            /\.config\.ts$/i,
            /\.module\.ts$/i,
            /migrations\//i,
            /seeders\//i,
            /test\.ts$/i,
            /spec\.ts$/i,
            /mock/i,
            /__tests__/i,
            /test\//i
          ];
          
          function shouldIgnore(filePath) {
            const normalized = filePath.toLowerCase();
            return IGNORE_PATTERNS.some(pattern => pattern.test(normalized));
          }
          
          function calculateFileAverage(data) {
            const { lines, statements, functions, branches } = data;
            const values = [
              lines?.pct || 0,
              statements?.pct || 0,
              functions?.pct || 0,
              branches?.pct || 0
            ].filter(val => !isNaN(val));
            
            return values.length > 0 
              ? values.reduce((sum, val) => sum + val, 0) / values.length 
              : 100; // Se nÃ£o tem dados, considera coberto
          }
          
          // 3. ANÃLISE POR ARQUIVO
          const results = {
            passed: [],
            failed: [],
            ignored: [],
            summary: {
              totalFiles: 0,
              analyzedFiles: 0,
              passedFiles: 0,
              failedFiles: 0,
              ignoredFiles: 0,
              overallCoverage: totalCoverage
            }
          };
          
          for (const [filePath, data] of Object.entries(coverageData)) {
            if (filePath === 'total') continue;
            
            results.summary.totalFiles++;
            
            // Verificar se deve ignorar
            if (shouldIgnore(filePath)) {
              results.ignored.push({
                file: filePath,
                reason: 'Matches ignore pattern (DTO/Enum/Interface/etc)'
              });
              results.summary.ignoredFiles++;
              continue;
            }
            
            // Calcular cobertura mÃ©dia do arquivo
            const avgCoverage = calculateFileAverage(data);
            const fileResult = {
              file: filePath,
              coverage: {
                lines: data.lines?.pct || 0,
                statements: data.statements?.pct || 0,
                functions: data.functions?.pct || 0,
                branches: data.branches?.pct || 0,
                average: Math.round(avgCoverage * 100) / 100
              }
            };
            
            results.summary.analyzedFiles++;
            
            // Classificar como passou ou falhou (80% POR ARQUIVO)
            if (fileResult.coverage.average >= MIN_COVERAGE) {
              results.passed.push(fileResult);
              results.summary.passedFiles++;
            } else {
              results.failed.push(fileResult);
              results.summary.failedFiles++;
            }
          }
          
          // 4. RELATÃ“RIO DETALHADO
          console.log('ğŸ“Š RESUMO DA ANÃLISE POR ARQUIVO:');
          console.log('----------------------------------');
          console.log(\`ğŸ“ Total de arquivos no projeto: \${results.summary.totalFiles}\`);
          console.log(\`ğŸ” Arquivos analisados para cobertura: \${results.summary.analyzedFiles}\`);
          console.log(\`â­ï¸  Arquivos ignorados (DTOs/Enums/etc): \${results.summary.ignoredFiles}\`);
          console.log(\`âœ… Arquivos com â‰¥\${MIN_COVERAGE}%: \${results.summary.passedFiles}\`);
          console.log(\`âŒ Arquivos com <\${MIN_COVERAGE}%: \${results.summary.failedFiles}\`);
          console.log(\`ğŸ“ˆ Cobertura total do projeto: \${results.summary.overallCoverage.toFixed(2)}%\`);
          
          // 5. SE HOUVER ARQUIVOS COM FALHA
          if (results.failed.length > 0) {
            console.log('\\nâŒâŒâŒ ARQUIVOS COM COBERTURA INSUFICIENTE (<80%):');
            console.log('==============================================\\n');
            
            results.failed.forEach((file, index) => {
              console.log(\`\${index + 1}. \${file.file}\`);
              console.log(\`   ğŸ“‰ Cobertura mÃ©dia: \${file.coverage.average}% (exigido: \${MIN_COVERAGE}%)\`);
              console.log(\`   ğŸ“Š Detalhes:\`);
              console.log(\`      â€¢ Lines: \${file.coverage.lines.toFixed(1)}%\`);
              console.log(\`      â€¢ Statements: \${file.coverage.statements.toFixed(1)}%\`);
              console.log(\`      â€¢ Functions: \${file.coverage.functions.toFixed(1)}%\`);
              console.log(\`      â€¢ Branches: \${file.coverage.branches.toFixed(1)}%\`);
              console.log('');
            });
            
            console.log('ğŸ”§ AÃ‡Ã•ES NECESSÃRIAS:');
            console.log('1. Adicione testes para os arquivos acima');
            console.log('2. Execute: npm test -- --coverage');
            console.log('3. Garanta que cada arquivo atinja 80%');
            console.log('4. Atualize este PR apÃ³s corrigir\\n');
            
            // Preparar dados para output
            const failedFilesList = results.failed.map(f => f.file).join('|');
            
            // Salvar arquivo com detalhes
            fs.writeFileSync(
              'coverage-per-file-results.json',
              JSON.stringify({
                validation_passed: false,
                requirement: '80% per file',
                summary: results.summary,
                failed_files: results.failed,
                passed_files_count: results.passed.length,
                timestamp: new Date().toISOString()
              }, null, 2)
            );
            
            // â­ CORREÃ‡ÃƒO: Salvar outputs em arquivo para GitHub Actions
            const outputs = {
              passed: 'false',
              failed_files: failedFilesList,
              failed_count: results.failed.length.toString(),
              coverage_summary: JSON.stringify(results.summary)
            };
            
            // Escrever outputs no formato correto
            const outputPath = process.env.GITHUB_OUTPUT || '/tmp/github_output.txt';
            let outputContent = '';
            for (const [key, value] of Object.entries(outputs)) {
              outputContent += \`\${key}=\${value}\n\`;
            }
            fs.writeFileSync(outputPath, outputContent, { flag: 'a' });
            
            console.log('âœ… Outputs saved for GitHub Actions');
            process.exit(1);
            
          } else {
            // 6. TODOS OS ARQUIVOS PASSARAM
            console.log('\\nğŸ‰ğŸ‰ğŸ‰ VALIDAÃ‡ÃƒO POR ARQUIVO APROVADA! ğŸ‰ğŸ‰ğŸ‰');
            console.log('==========================================');
            console.log(\`âœ… Todos \${results.summary.analyzedFiles} arquivos atendem \${MIN_COVERAGE}% de cobertura\`);
            
            // Mostrar alguns exemplos
            if (results.passed.length > 0) {
              console.log('\\nğŸ† Top 3 arquivos com melhor cobertura:');
              const topFiles = [...results.passed]
                .sort((a, b) => b.coverage.average - a.coverage.average)
                .slice(0, 3);
              
              topFiles.forEach((file, i) => {
                console.log(\`  \${i + 1}. \${file.file} - \${file.coverage.average}%\`);
              });
            }
            
            // Salvar resultados
            fs.writeFileSync(
              'coverage-per-file-results.json',
              JSON.stringify({
                validation_passed: true,
                requirement: '80% per file',
                summary: results.summary,
                passed_files_count: results.passed.length,
                timestamp: new Date().toISOString()
              }, null, 2)
            );
            
            // â­ CORREÃ‡ÃƒO: Salvar outputs em arquivo para GitHub Actions
            const outputs = {
              passed: 'true',
              failed_files: '',
              failed_count: '0',
              coverage_summary: JSON.stringify(results.summary)
            };
            
            // Escrever outputs no formato correto
            const outputPath = process.env.GITHUB_OUTPUT || '/tmp/github_output.txt';
            let outputContent = '';
            for (const [key, value] of Object.entries(outputs)) {
              outputContent += \`\${key}=\${value}\n\`;
            }
            fs.writeFileSync(outputPath, outputContent, { flag: 'a' });
            
            console.log('âœ… Outputs saved for GitHub Actions');
          }
          "

      - name: ğŸ’¾ Save coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-per-file-report-${{ github.sha }}
          path: |
            coverage/
            coverage-per-file-results.json
          retention-days: 30
          
      - name: âœ… Report job completion
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Job 'verify-coverage-per-file' completed successfully"
          else
            echo "âŒ Job 'verify-coverage-per-file' failed"
          fi

  sonarqube-analysis:
    name: ğŸ“¡ SonarQube Analysis
    needs: verify-coverage-per-file
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    if: needs.verify-coverage-per-file.outputs.coverage_passed == 'true'
    
    timeout-minutes: 10
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: ğŸ“¦ Install dependencies
        run: npm ci
        
      - name: ğŸ“ Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-per-file-report-${{ github.sha }}
          path: coverage/
          
      - name: ğŸ” Run SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.organization=${{ vars.SONAR_ORGANIZATION }}
            -Dsonar.projectKey=${{ vars.SONAR_PROJECT_KEY }}
            -Dsonar.qualitygate.wait=true
            -Dsonar.coverage.exclusions=${{ env.IGNORE_PATTERNS }}
            -Dsonar.pullrequest.key=${{ github.event.pull_request.number }}
            -Dsonar.pullrequest.branch=${{ github.head_ref }}
            -Dsonar.pullrequest.base=${{ github.base_ref }}
            -Dsonar.analysis.detectedBranch=true
            
      - name: âœ… Report job completion
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Job 'sonarqube-analysis' completed successfully"
          else
            echo "âŒ Job 'sonarqube-analysis' failed"
          fi

  block-pr-on-failure:
    name: ğŸš« Block PR IF Insufficient File Coverage
    needs: verify-coverage-per-file
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    if: |
      github.event_name == 'pull_request' && 
      needs.verify-coverage-per-file.outputs.coverage_passed == 'false'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“ Download results
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-per-file-report-*
          merge-multiple: true
          
      - name: ğŸ“ Create detailed PR comment
        uses: actions/github-script@v6
        env:
          FAILED_FILES: ${{ needs.verify-coverage-per-file.outputs.failed_files }}
          FAILED_COUNT: ${{ needs.verify-coverage-per-file.outputs.failed_count }}
          COVERAGE_SUMMARY: ${{ needs.verify-coverage-per-file.outputs.coverage_summary }}
        with:
          script: |
            const { FAILED_FILES, FAILED_COUNT, COVERAGE_SUMMARY } = process.env;
            
            let summary = {};
            try {
              summary = JSON.parse(COVERAGE_SUMMARY || '{}');
            } catch (e) {
              summary = { analyzedFiles: 0, failedFiles: 0 };
            }
            
            const failedFiles = FAILED_FILES ? FAILED_FILES.split('|') : [];
            const failedCount = parseInt(FAILED_COUNT || '0');
            
            let comment = `## ğŸš« PR BLOQUEADO - Cobertura Insuficiente por Arquivo\n\n`;
            comment += `### âŒ ValidaÃ§Ã£o Falhou: 80% de cobertura por arquivo nÃ£o atendida\n\n`;
            
            comment += `### ğŸ“Š EstatÃ­sticas da AnÃ¡lise:\n`;
            comment += `- **Arquivos analisados:** ${summary.analyzedFiles || 0}\n`;
            comment += `- **Arquivos com falha (<80%):** ${failedCount}\n`;
            comment += `- **Arquivos aprovados (â‰¥80%):** ${summary.passedFiles || 0}\n`;
            comment += `- **Arquivos ignorados (DTOs/Enums/etc):** ${summary.ignoredFiles || 0}\n`;
            comment += `- **Cobertura total do projeto:** ${summary.overallCoverage ? summary.overallCoverage.toFixed(2) : 'N/A'}%\n\n`;
            
            if (failedFiles.length > 0) {
              comment += `### ğŸ“ Arquivos que Necessitam de Mais Testes:\n`;
              failedFiles.forEach((file, index) => {
                comment += `${index + 1}. \`${file}\`\n`;
              });
              comment += `\n`;
            }
            
            comment += `### ğŸ”§ Como Resolver:\n`;
            comment += `1. **Adicione testes unitÃ¡rios** para cada arquivo listado acima\n`;
            comment += `2. Execute localmente: \`npm test -- --coverage\`\n`;
            comment += `3. **Verifique se cada arquivo individual** atinge 80% de cobertura\n`;
            comment += `4. **Cobertura Ã© calculada por:** Linhas + Statements + Functions + Branches\n`;
            comment += `5. Atualize este PR apÃ³s corrigir\n\n`;
            
            comment += `> **Nota:** Esta validaÃ§Ã£o Ã© mais rigorosa que o requisito do professor (70% total).\n`;
            comment += `> **Arquivos ignorados:** DTOs, Enums, Interfaces, Value Objects, main.ts, configs, migrations.\n`;
            
            // Adicionar comentÃ¡rio no PR
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
            // Adicionar review request changes
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: 'REQUEST_CHANGES',
              body: `âŒ PR bloqueado: ${failedCount} arquivo(s) nÃ£o atendem 80% de cobertura individual.`
            });
            
      - name: ğŸš« Fail workflow to block merge
        run: |
          echo "================================================"
          echo "ğŸš«ğŸš«ğŸš«        PR BLOQUEADO AUTOMATICAMENTE    ğŸš«ğŸš«ğŸš«"
          echo "================================================"
          echo ""
          echo "MOTIVO: ValidaÃ§Ã£o de 80% de cobertura por arquivo falhou"
          echo ""
          echo "RESUMO:"
          echo "- Um ou mais arquivos tÃªm cobertura < 80%"
          echo "- Verifique o comentÃ¡rio no PR para detalhes"
          echo ""
          echo "PRÃ“XIMOS PASSOS:"
          echo "1. Verifique os arquivos listados no comentÃ¡rio do PR"
          echo "2. Adicione testes unitÃ¡rios para esses arquivos"
          echo "3. Execute: npm test -- --coverage"
          echo "4. Confirme que cada arquivo atinge 80%"
          echo "5. Atualize este PR"
          echo ""
          echo "Arquivos com problema foram salvos em coverage-per-file-results.json"
          echo "================================================"
          exit 1

  final-validation:
    name: âœ… Final Validation & Summary
    needs: [verify-coverage-per-file, sonarqube-analysis]
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    if: |
      github.event_name == 'pull_request' &&
      needs.verify-coverage-per-file.result == 'success' &&
      (needs.sonarqube-analysis.result == 'success' || needs.sonarqube-analysis.result == 'skipped')
    
    steps:
      - name: ğŸ“‹ Create success summary
        uses: actions/github-script@v6
        env:
          COVERAGE_SUMMARY: ${{ needs.verify-coverage-per-file.outputs.coverage_summary }}
        with:
          script: |
            let summary = {};
            try {
              summary = JSON.parse(process.env.COVERAGE_SUMMARY || '{}');
            } catch (e) {
              summary = { analyzedFiles: 0, overallCoverage: 0 };
            }
            
            let comment = `## âœ…âœ…âœ… TODAS AS VALIDAÃ‡Ã•ES PASSARAM! âœ…âœ…âœ…\n\n`;
            comment += `### ğŸ‰ PR Pronto para Merge\n\n`;
            
            comment += `### ğŸ“Š ValidaÃ§Ã£o por Arquivo Aprovada:\n`;
            comment += `- **Arquivos analisados:** ${summary.analyzedFiles || 0}\n`;
            comment += `- **Arquivos aprovados (â‰¥80%):** ${summary.passedFiles || 0}\n`;
            comment += `- **Cobertura total:** ${summary.overallCoverage ? summary.overallCoverage.toFixed(2) : 'N/A'}%\n`;
            comment += `- **SonarQube Analysis:** âœ… Completa\n\n`;
            
            comment += `### ğŸ¯ Requisitos Atendidos:\n`;
            comment += `1. âœ… **80% de cobertura por arquivo** (seu requisito extra)\n`;
            comment += `2. âœ… **Build da aplicaÃ§Ã£o**\n`;
            comment += `3. âœ… **AnÃ¡lise SonarQube** (qualidade do cÃ³digo)\n`;
            comment += `4. âœ… **Quality Gate do SonarQube**\n\n`;
            
            comment += `### ğŸ‘¥ PrÃ³ximos Passos:\n`;
            comment += `1. Aguarde aprovaÃ§Ã£o de review do time\n`;
            comment += `2. Merge para main quando aprovado\n`;
            comment += `3. Deploy automÃ¡tico (se configurado)\n\n`;
            
            comment += `> **Excelente trabalho!** O cÃ³digo atende todos os requisitos de qualidade. ğŸš€\n`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
      - name: ğŸ‰ All checks passed
        run: |
          echo "========================================"
          echo "âœ…âœ…âœ… ALL VALIDATIONS PASSED! âœ…âœ…âœ…"
          echo "========================================"
          echo ""
          echo "âœ“ Build: Successful"
          echo "âœ“ Test coverage: â‰¥80% PER FILE (validated)"
          echo "âœ“ SonarQube analysis: Completed"
          echo "âœ“ Code quality: Meets standards"
          echo ""
          echo "This PR is ready for manual review and merge!"
          echo ""
          echo "Files analyzed: ${{ needs.verify-coverage-per-file.outputs.coverage_summary.analyzedFiles || 'N/A' }}"
          echo "Overall coverage: ${{ needs.verify-coverage-per-file.outputs.coverage_summary.overallCoverage || 'N/A' }}%"
          echo ""
          echo "ğŸš€ Ready to merge! ğŸš€"
          
      - name: âœ… Report final validation completion
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Job 'final-validation' completed successfully"
          else
            echo "âŒ Job 'final-validation' failed"
          fi