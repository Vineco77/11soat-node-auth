name: SonarQube Analysis - 80% Coverage per File

on:
  pull_request:
    branches: [main, master]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

env:
  MIN_COVERAGE: 80
  IGNORE_PATTERNS: "**/*.dto.ts,**/*.enum.ts,**/value-objects/**,**/*.interface.ts,**/main.ts,**/index.ts,**/*.config.ts,**/migrations/**,**/seeders/**,**/*.module.ts"

jobs:
  # â­ NOME DO CHECK: ğŸ—ï¸ Build & Test
  build-and-test:
    name: ğŸ—ï¸ Build & Test
    runs-on: ubuntu-latest  # â­ MANTENHA ubuntu-latest (nÃ£o container Alpine)
    
    timeout-minutes: 20
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: ğŸ“¦ Install dependencies
        run: npm ci
        
      - name: ğŸ—ï¸ Build application
        run: npm run build
        
      - name: ğŸ§ª Run tests with coverage
        id: run-tests
        run: |
          echo "Running tests with coverage..."
          npm test -- --coverage --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text
          
          if [ -f "coverage/lcov.info" ]; then
            echo "âœ… lcov.info generated successfully"
            echo "File size: $(wc -l < coverage/lcov.info) lines"
          else
            echo "âŒ ERROR: lcov.info not generated!"
            ls -la coverage/ 2>/dev/null || echo "No coverage directory"
            exit 1
          fi

  # â­ NOME DO CHECK: ğŸ”¬ Verify 80% Coverage PER FILE
  verify-coverage:
    name: ğŸ”¬ Verify 80% Coverage PER FILE
    needs: build-and-test
    runs-on: ubuntu-latest  # â­ MANTENHA ubuntu-latest
    
    timeout-minutes: 15
    
    outputs:
      coverage_passed: ${{ steps.check-coverage.outputs.passed }}
      failed_files: ${{ steps.check-coverage.outputs.failed_files }}
      failed_count: ${{ steps.check-coverage.outputs.failed_count }}
      coverage_summary: ${{ steps.check-coverage.outputs.coverage_summary }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: ğŸ“¦ Install dependencies
        run: npm ci
        
      - name: ğŸ“Š Generate coverage report
        run: |
          npm test -- --coverage \
            --coverageReporters=json-summary \
            --coverageReporters=lcov \
            --coverageReporters=text \
            --coverageReporters=html
        
      - name: ğŸ” Validate 80% Coverage PER FILE
        id: check-coverage
        run: |
          # Criar um arquivo JavaScript separado para evitar problemas de escape
          cat > check-coverage.js << 'EOF'
          const fs = require('fs');
          
          console.log('ğŸ” VALIDAÃ‡ÃƒO: 80% de cobertura POR ARQUIVO');
          console.log('===========================================');
          
          // 1. CARREGAR RELATÃ“RIO
          const summaryPath = './coverage/coverage-summary.json';
          if (!fs.existsSync(summaryPath)) {
            console.error('âŒ RelatÃ³rio de cobertura nÃ£o encontrado!');
            process.exit(1);
          }
          
          const coverageData = require(summaryPath);
          const MIN_COVERAGE = 80;
          const totalCoverage = coverageData.total?.lines?.pct || 0;
          
          // 2. PADRÃ•ES DE IGNORAÃ‡ÃƒO
          const IGNORE_PATTERNS = [
            /\.dto\.ts$/i,
            /\.enum\.ts$/i,
            /\.interface\.ts$/i,
            /\/value-objects\//i,
            /main\.ts$/i,
            /index\.ts$/i,
            /\.config\.ts$/i,
            /\.module\.ts$/i,
            /migrations\//i,
            /seeders\//i,
            /test\.ts$/i,
            /spec\.ts$/i,
            /mock/i,
            /__tests__/i,
            /test\//i
          ];
          
          function shouldIgnore(filePath) {
            const normalized = filePath.toLowerCase();
            return IGNORE_PATTERNS.some(pattern => pattern.test(normalized));
          }
          
          function calculateFileAverage(data) {
            const { lines, statements, functions, branches } = data;
            const values = [
              lines?.pct || 0,
              statements?.pct || 0,
              functions?.pct || 0,
              branches?.pct || 0
            ].filter(val => !isNaN(val));
            
            return values.length > 0 
              ? values.reduce((sum, val) => sum + val, 0) / values.length 
              : 100;
          }
          
          // 3. ANÃLISE POR ARQUIVO
          const results = {
            passed: [],
            failed: [],
            ignored: [],
            summary: {
              totalFiles: 0,
              analyzedFiles: 0,
              passedFiles: 0,
              failedFiles: 0,
              ignoredFiles: 0,
              overallCoverage: totalCoverage
            }
          };
          
          for (const [filePath, data] of Object.entries(coverageData)) {
            if (filePath === 'total') continue;
            
            results.summary.totalFiles++;
            
            if (shouldIgnore(filePath)) {
              results.ignored.push({ file: filePath, reason: 'Matches ignore pattern' });
              results.summary.ignoredFiles++;
              continue;
            }
            
            const avgCoverage = calculateFileAverage(data);
            const fileResult = {
              file: filePath,
              coverage: {
                lines: data.lines?.pct || 0,
                statements: data.statements?.pct || 0,
                functions: data.functions?.pct || 0,
                branches: data.branches?.pct || 0,
                average: Math.round(avgCoverage * 100) / 100
              }
            };
            
            results.summary.analyzedFiles++;
            
            if (fileResult.coverage.average >= MIN_COVERAGE) {
              results.passed.push(fileResult);
              results.summary.passedFiles++;
            } else {
              results.failed.push(fileResult);
              results.summary.failedFiles++;
            }
          }
          
          // 4. RELATÃ“RIO
          console.log('ğŸ“Š RESUMO:');
          console.log(\`ğŸ“ Total de arquivos: \${results.summary.totalFiles}\`);
          console.log(\`ğŸ” Analisados: \${results.summary.analyzedFiles}\`);
          console.log(\`â­ï¸  Ignorados: \${results.summary.ignoredFiles}\`);
          console.log(\`âœ… Aprovados (â‰¥\${MIN_COVERAGE}%): \${results.summary.passedFiles}\`);
          console.log(\`âŒ Reprovados: \${results.summary.failedFiles}\`);
          console.log(\`ğŸ“ˆ Cobertura total: \${results.summary.overallCoverage.toFixed(2)}%\`);
          
          // 5. SE HOUVER FALHAS
          if (results.failed.length > 0) {
            console.log('\\nâŒ ARQUIVOS COM COBERTURA INSUFICIENTE (<80%):\\n');
            
            results.failed.forEach((file, index) => {
              console.log(\`\${index + 1}. \${file.file}\`);
              console.log(\`   ğŸ“‰ MÃ©dia: \${file.coverage.average}%\`);
            });
            
            const failedFilesList = results.failed.map(f => f.file).join('|');
            
            fs.writeFileSync(
              'coverage-per-file-results.json',
              JSON.stringify({
                validation_passed: false,
                summary: results.summary,
                failed_files: results.failed
              }, null, 2)
            );
            
            // OUTPUTS PARA GITHUB ACTIONS
            const githubOutput = process.env.GITHUB_OUTPUT;
            if (githubOutput) {
              fs.appendFileSync(githubOutput, \`passed=false\\n\`);
              fs.appendFileSync(githubOutput, \`failed_files=\${failedFilesList}\\n\`);
              fs.appendFileSync(githubOutput, \`failed_count=\${results.failed.length}\\n\`);
              fs.appendFileSync(githubOutput, \`coverage_summary=\${JSON.stringify(results.summary)}\\n\`);
            }
            
            process.exit(1);
            
          } else {
            // 6. TODOS PASSARAM
            console.log('\\nğŸ‰ VALIDAÃ‡ÃƒO POR ARQUIVO APROVADA!');
            
            fs.writeFileSync(
              'coverage-per-file-results.json',
              JSON.stringify({
                validation_passed: true,
                summary: results.summary
              }, null, 2)
            );
            
            // OUTPUTS PARA GITHUB ACTIONS
            const githubOutput = process.env.GITHUB_OUTPUT;
            if (githubOutput) {
              fs.appendFileSync(githubOutput, \`passed=true\\n\`);
              fs.appendFileSync(githubOutput, \`failed_files=\\n\`);
              fs.appendFileSync(githubOutput, \`failed_count=0\\n\`);
              fs.appendFileSync(githubOutput, \`coverage_summary=\${JSON.stringify(results.summary)}\\n\`);
            }
          }
          EOF
          
          # Executar o script
          node check-coverage.js
          
      - name: ğŸ’¾ Save artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ github.sha }}
          path: |
            coverage/
            coverage-per-file-results.json
          retention-days: 30

  # â­ NOME DO CHECK: ğŸ“¡ SonarQube Analysis
  sonarqube-analysis:
    name: ğŸ“¡ SonarQube Analysis
    needs: verify-coverage
    runs-on: ubuntu-latest  # â­ MANTENHA ubuntu-latest
    
    # SÃ³ executa se a validaÃ§Ã£o de cobertura passar
    if: needs.verify-coverage.outputs.coverage_passed == 'true'
    
    timeout-minutes: 15
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: ğŸ“¦ Install dependencies
        run: npm ci
        
      - name: ğŸ“ Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report-${{ github.sha }}
          path: coverage/
          
      - name: ğŸ” Run SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          # â­ REMOVA O CONTAINER DO SONAR ACTION
          # A action jÃ¡ lida com isso internamente
          args: >
            -Dsonar.organization=${{ vars.SONAR_ORGANIZATION }}
            -Dsonar.projectKey=${{ vars.SONAR_PROJECT_KEY }}
            -Dsonar.qualitygate.wait=true
            -Dsonar.coverage.exclusions=${{ env.IGNORE_PATTERNS }}
            -Dsonar.pullrequest.key=${{ github.event.pull_request.number }}
            -Dsonar.pullrequest.branch=${{ github.head_ref }}
            -Dsonar.pullrequest.base=${{ github.base_ref }}

  block-pr-on-failure:
    name: ğŸš« Block PR - Insufficient File Coverage
    needs: verify-coverage
    runs-on: ubuntu-latest
    
    # SÃ³ executa se a validaÃ§Ã£o falhar
    if: |
      github.event_name == 'pull_request' && 
      needs.verify-coverage.outputs.coverage_passed == 'false'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“ Download results
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-report-*
          merge-multiple: true
          
      - name: ğŸ“ Create PR comment
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            let results = {};
            try {
              results = JSON.parse(fs.readFileSync('coverage-per-file-results.json', 'utf8'));
            } catch (e) {
              results = { summary: { failedFiles: 0 } };
            }
            
            const comment = \`## ğŸš« PR BLOQUEADO - Cobertura Insuficiente\\n\\n\` +
                           \`âŒ ValidaÃ§Ã£o de 80% de cobertura por arquivo falhou.\\n\\n\` +
                           \`**Arquivos com falha:** \${results.summary.failedFiles || 0}\\n\\n\` +
                           \`**AÃ§Ãµes necessÃ¡rias:**\\n\` +
                           \`1. Adicione testes para os arquivos listados\\n\` +
                           \`2. Execute: \\\`npm test -- --coverage\\\`\\n\` +
                           \`3. Atualize este PR\`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
      - name: ğŸš« Fail workflow
        run: exit 1

  final-validation:
    name: âœ… Final Validation
    needs: [verify-coverage, sonarqube-analysis]
    runs-on: ubuntu-latest
    
    if: |
      github.event_name == 'pull_request' &&
      needs.verify-coverage.result == 'success' &&
      (needs.sonarqube-analysis.result == 'success' || needs.sonarqube-analysis.result == 'skipped')
    
    steps:
      - name: ğŸ“ Create success comment
        uses: actions/github-script@v6
        with:
          script: |
            const comment = \`## âœ… TODAS AS VALIDAÃ‡Ã•ES PASSARAM!\\n\\n\` +
                           \`ğŸ‰ PR pronto para review e merge.\\n\\n\` +
                           \`âœ… Build e testes aprovados\\n\` +
                           \`âœ… 80% de cobertura por arquivo validada\\n\` +
                           \`âœ… AnÃ¡lise SonarQube completa\`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
      - name: ğŸ‰ Success
        run: echo "âœ… All checks passed - PR ready for merge"